main: aliuly\grabbag\Main
api: [1.10.0,1.11.0,1.12.0]
load: POSTWORLD

name: GrabBag
description: Collection of miscellaneous commands and listener modules
version: 2.3.0
author: aliuly
website: https://github.com/alejandroliu/pocketmine-plugins/tree/master/GrabBag
softdepend: FastTransfer
<?php
//= cfg:features
//:
//: This section you can enable/disable commands and listener modules.
//: You do this in order to avoid conflicts between different
//: PocketMine-MP plugins.  It has one line per feature:
//:
//:    feature: true|false
//:
//: If **true** the feature is enabled.  if **false** the feature is disabled.
namespace aliuly\grabbag;

use pocketmine\plugin\PluginBase;
use pocketmine\event\Listener;
use pocketmine\command\CommandSender;
use pocketmine\utils\Config;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\BasicPlugin;
use aliuly\grabbag\api\GrabBag as GrabBagAPI;

class Main extends BasicPlugin {
	public $api;
	public function onEnable(){
		$this->api = new GrabBagAPI($this);
		if (!is_dir($this->getDataFolder())) mkdir($this->getDataFolder());
		mc::plugin_init($this,$this->getFile());
		$features = [
			"players" => [ "CmdPlayers", true ],
			"ops" => [ "CmdOps", true ],
			"gm?" => [ "CmdGmx", true ],
			"as" => [ "CmdAs", true ],
			"slay" => [ "CmdSlay", true ],
			"heal" => [ "CmdHeal", true ],
			"whois" => [ "CmdWhois", true ],
			"mute-unmute" => [ "CmdMuteMgr", true ],
			"freeze-thaw" => [ "CmdFreezeMgr", true ],
			"showtimings" => [ "CmdTimings", true ],
			"seeinv-seearmor" => [ "CmdShowInv", true ],
			"clearinv" => [ "CmdClearInv", true ],
			"get" => [ "CmdGet", true ],
			"shield" => [ "CmdShieldMgr", true ],
			"srvmode" => [ "CmdSrvModeMgr", true ],
			"opms-rpt" => [ "CmdOpMsg", true ],
			"entities" => [ "CmdEntities", true ],
			"after-at" => [ "CmdAfterAt", true ],
			"summon-dismiss" => [ "CmdSummon", true ],
			"pushtp-poptp" => [ "CmdTpStack", true ],
			"prefix" => [ "CmdPrefixMgr", true ],
			"spawn" => [ "CmdSpawn", true ],
			"burn" => [ "CmdBurn", true ],
			"blowup" => [ "CmdBlowUp", true ],
			"setarmor" => [ "CmdSetArmor", true ],
			"spectator"=> [ "CmdSpectator", false ],
			"followers"=> [ "CmdFollowMgr", true ],
			"rcon-client" => [ ["ServerList","CmdRcon"], true ],
			"join-mgr" => [ "JoinMgr", true ],
			"repeater" => [ "RepeatMgr", true ],
			"broadcast-tp" => [ "BcTpMgr", true ],
			"crash" => ["CmdCrash", true],
			"pluginmgr" => ["CmdPluginMgr", true],
			"permmgr" => ["CmdPermMgr", true],
			"throw" => ["CmdThrow", true],
			"regmgr" => ["CmdRegMgr",true],
			"invisible" => ["CmdInvisible",true],
			"chat-utils" => ["CmdChatMgr",true],
			"query-hosts" => [ ["ServerList","CmdQuery"], true],
			"cmd-selector" => ["CmdSelMgr", true],
			"cmd-alias" => ["CmdAlias", true],
			"reop" => ["CmdReOp" , true],
		];
		if (MPMU::apiVersion("1.12.0")) {
			$features["fly"] = [ "CmdFly", true ];
			$features["skinner"] = [ "CmdSkinner", true ];
			$features["blood-particles"] = [ "BloodMgr", true ];
			$ft = $this->getServer()->getPluginManager()->getPlugin("FastTransfer");
			if ($ft) {
				$features["broadcast-ft"] = [ "TransferMgr", true ];
				$features["ftservers"] = [ ["ServerList","CmdFTServers"] , true];
			}
		}

		$cfg = $this->modConfig(__NAMESPACE__,$features, [
			"version" => $this->getDescription()->getVersion(),
			"serverlist" => [],
			"join-mgr" => JoinMgr::defaults(),
			"broadcast-tp" => BcTpMgr::defaults(),
			"freeze-thaw" => CmdFreezeMgr::defaults(),
			"cmd-selector" => CmdSelMgr::defaults(),
		]);
	}
	public function rconDone($res,$data) {
		if (!isset($this->modules["rcon-client"])) return;
		$this->modules["rcon-client"]->taskDone($res,$data);
	}
}
<?php
namespace aliuly\grabbag\common;

use pocketmine\plugin\PluginBase;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\command\CommandExecutor;
use pocketmine\utils\TextFormat;
use pocketmine\utils\Config;

use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\BasicHelp;
use aliuly\grabbag\common\Session;
use aliuly\grabbag\common\SubCommandMap;

/**
 * Simple extension to the PocketMine PluginBase class
 */
abstract class BasicPlugin extends PluginBase {
	protected $modules = [];
	protected $scmdMap = null;
	protected $session;

	/**
	 * Given some defaults, this will load optional features
	 *
	 * @param str $ns - namespace used to search for classes to load
	 * @param array $mods - optional module definition
	 * @param array $defaults - default options to use for config.yml
	 * @param str $xhlp - optional help format.
	 * @return array
	 */
	protected function modConfig($ns,$mods,$defaults,$xhlp="") {
		if (!isset($defaults["features"])) $defaults["features"] = [];
		foreach ($mods as $i => $j) {
			$defaults["features"][$i] = $j[1];
		}
		$cfg=(new Config($this->getDataFolder()."config.yml",
									  Config::YAML,$defaults))->getAll();
		$this->modules = [];
		foreach ($cfg["features"] as $i=>$j) {
			if (!isset($mods[$i])) {
				$this->getLogger()->info(mc::_("Unknown feature \"%1%\" ignored.",$i));
				continue;
			}
			if (!$j) continue;
			$class = $mods[$i][0];
			if (is_array($class)) {
				while (count($class) > 1) {
					// All classes before the last one are dependencies...
					$classname = $dep = array_shift($class);
					if(strpos($classname,"\\") === false) $classname = $ns."\\".$classname;
					if (isset($this->modules[$dep])) continue; // Dependancy already loaded
					if(isset($cfg[strtolower($dep)])) {
						$this->modules[$dep] = new $classname($this,$cfg[strtolower($dep)]);
					} else {
						$this->modules[$dep] = new $classname($this);
					}
				}
				// The last class in the array implements the actual feature
				$class = array_shift($class);
			}
			if(strpos($class,"\\") === false) $class = $ns."\\".$class;
			if (isset($cfg[$i]))
				$this->modules[$i] = new $class($this,$cfg[$i]);
			else
				$this->modules[$i] = new $class($this);
		}
		$c = count($this->modules);
		if ($c == 0) {
			$this->getLogger()->info(mc::_("NO features enabled"));
			return;
		}
		$this->session = null;
		$this->getLogger()->info(mc::n(mc::_("Enabled one feature"),
													 mc::_("Enabled %1% features",$c),
													 $c));
		if ($this->scmdMap !== null && $this->scmdMap->getCommandCount() > 0) {
			$this->modules[] = new BasicHelp($this,$xhlp);
		}
		return $cfg;
	}
  /**
	 * Get module
	 * @param str $module - module to retrieve
	 * @return mixed|null
	 */
	public function getModule($str) {
		if (isset($this->modules[$str])) return $this->modules[$str];
		return null;
	}
	/**
	 * Save a config section to the plugins' config.yml
	 *
	 * @param str $key - section to save
	 * @param mixed $settings - settings to save
	 */
	public function cfgSave($key,$settings) {
		$cfg=new Config($this->getDataFolder()."config.yml",Config::YAML);
		$dat = $cfg->getAll();
		$dat[$key] = $settings;
		$cfg->setAll($dat);
		$cfg->save();
	}
	/**
	 * Dispatch commands using sub command table
	 */
	protected function dispatchSCmd(CommandSender $sender,Command $cmd,array $args,$data=null) {
		if ($this->scmdMap === null) {
			$sender->sendMessage(mc::_("No sub-commands available"));
			return false;
		}
		return $this->scmdMap->dispatchSCmd($sender,$cmd,$args,$data);
	}
	/** Look-up sub command map
	 * @returns SubCommandMap
	 */
	public function getSCmdMap() {
		return $this->scmdMap;
	}
	/**
	 * Register a sub command
	 * @param str $cmd - sub command
	 * @param callable $callable - callable to execute
	 * @param array $opts - additional options
	 */
	public function registerSCmd($cmd,$callable,$opts) {
		if ($this->scmdMap === null) {
			$this->scmdMap = new SubCommandMap();
		}
		$this->scmdMap->registerSCmd($cmd,$callable,$opts);
	}
	/**
	 * Get a player state for the desired module/$label.
	 *
	 * @param str $label - state variable to get
	 * @param Player|str $player - Player instance or name
	 * @param mixed $default - default value to return is no state found
	 * @return mixed
	 */
	public function getState($label,$player,$default) {
		if ($this->session === null) return $default;
		return $this->session->getState($label,$player,$default);
	}
	/**
	 * Set a player related state
	 *
	 * @param str $label - state variable to set
	 * @param Player|str $player - player instance or their name
	 * @param mixed $val - value to set
	 * @return mixed
	 */
	public function setState($label,$player,$val) {
		if ($this->session === null) $this->session = new Session($this);
		return $this->session->setState($label,$player,$val);
	}
	/**
	 * Clears a player related state
	 *
	 * @param str $label - state variable to clear
	 * @param Player|str $player - intance of Player or their name
	 */
	public function unsetState($label,$player) {
		if ($this->session === null) return;
		$this->session->unsetState($label,$player);
	}

	/**
	 * Gets the contents of an embedded resource on the plugin file.
	 *
	 * @param string $filename
	 * @return string|null
	 */
	public function getResourceContents($filename){
		$fp = $this->getResource($filename);
		if($fp === null){
			return null;
		}
		$contents = stream_get_contents($fp);
		fclose($fp);
		return $contents;
	}
	/**
	 * Lets you dump the messages.ini file
	 */
	 public function getMessagesIni(){
		 return $this->getResourceContents("messages/messages.ini");
	 }
}
<?php
namespace aliuly\grabbag\api;

use aliuly\grabbag\Main as GrabBagPlugin;
use pocketmine\Player;
use pocketmine\entity\Human;
use pocketmine\command\CommandSender;

use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\ExpandVars;
use aliuly\grabbag\common\PMScript;

/**
 * GrabBag API
 *
 * Example Usage:
 *
 * Check if GrabBag is installed....
 * <code>
 * $api = null;
 * if (($plugin = $server->getPluginManager()->getPlugin("GrabBag") !== null) && $plugin->isEnabled() && MPMU::apiCheck($plugin->getDescription()->getVersion(),"2.3")) {
 *   if ($plugin->api->getFeature("freeze-thaw")) $api = $plugin->api;
 * }
 * </code>
 *
 * Call an API function:
 *
 * <code>
 *   $api->freeze($player);
 * </code>
 */
class GrabBag {
  protected $plugin;
  protected $vars;
  protected $interp;
  /**
   * @param GrabBagPlugin $owner - plugin that owns this session
   */
  public function __construct(GrabBagPlugin $owner) {
    $this->plugin = $owner;
    $this->vars = null;
    $this->interp = null;
  }
  /**
   * Check if module is available...
   * This will throw an exception if the module is not available
   * @param str $module - module name
   * @return mixed|null
   */
  public function getModule($module) {
    $vp = $this->plugin->getModule($module);
    if ($vp === null) throw new \RuntimeException("Missing module: " . $module);
    return $vp;
  }
  /**
   * Check if feature is supported and has been enabled in the GrabBag
   * configuration file.
   * @param str $feature - module name
   * @return bool
   */
   public function getFeature($feature) {
     if (!in_array($feature,[
       "freeze-thaw", "invisible", "after-at", "cmd-alias", "blowup",
       "chat-utils", "followers", "mute-unmute", "opms-rpt", "reop",
       "shield", "skinner", "slay", "spawn", "srvmode", "summon-dismiss",
       "throw", "pushtp-poptp",
       "ServerList",
     ])) return false;
     if ($this->plugin->getModule($feature) === null) return false;
     return true;
   }
   /**
    * Currently un-implemented
    */
   public function getVars() {
     if ($this->vars === null) {
       $this->vars = new ExpandVars($this->plugin);
     }
     return $this->vars;
   }
   /**
    * Currently un-implemented
    */
   public function getInterp() {
     if ($this->interp == null) {
       $this->interp  = new PMScript($this->plugin,$this->getVars());
     }
     return $this->interp;
   }

  //////////////////////////////////////////////////////////////
  // CmdFreeze
  //////////////////////////////////////////////////////////////
  /**
   * Checks if hard or soft freezing
   * @return bool
   */
  public function isHardFreeze() {
    return $this->getModule("freeze-thaw")->isHardFreeze();
  }
  /**
   * Sets hard or soft freezing
   * @param bool $hard - if true (default) hard freeze is in effect.
   */
  public function setHardFreeze($hard = true) {
    $this->getModule("freeze-thaw")->setHardFreeze($hard);
  }
  /**
   * Freeze given player
   * @param Player $player - player to freeze
   * @param bool $freeze - if true (default) freeze, if false, thaw.
   */
  public function freeze(Player $player, $freeze = true) {
    $this->getModule("freeze-thaw")->freeze($player,$freeze);
  }
  /**
   * Return a list of frozen players
   * @return str[]
   */
  public function getFrosties() {
    return $this->getModule("freeze-thaw")->getFrosties();
  }
  //////////////////////////////////////////////////////////////
  // CmdInvisible
  //////////////////////////////////////////////////////////////
  /**
   * Make player invisible
   * @param Player $player - player to change
   * @param bool $invis - if true (default) invisible, if false, visible.
   */
  public function invisible(Player $player, $invis) {
    if ($invis) {
      if (!$this->getModule("invisible")->isInvisible($player))
        $this->getModule("invisible")->activate($player);
    } else {
      if ($this->getModule("invisible")->isInvisible($player))
        $this->getModule("invisible")->deactivate($player);
    }
  }
  /**
   * Check if player is invisible...
   * @param Player $player - player to check
   */
  public function isInvisible(Player $player) {
    return $this->getModule("invisible")->isInvisible($player);
  }
  //////////////////////////////////////////////////////////////
  // CmdAfterAt
  //////////////////////////////////////////////////////////////
  /**
   * Schedule a command to be run
   * @param int $secs - execute after this number of seconds
   * @param str $cmdline - command line to execute
   */
  public function after($cmdline,$secs) {
    $this->getModule("after-at")->schedule($secs,$cmdline);
  }
  //////////////////////////////////////////////////////////////
  // CmdAlias
  //////////////////////////////////////////////////////////////
  /**
   * Define a command alias
   * @param str $alias - alias name
   * @param str $cmdline - command line to execute
   * @param bool $force - overwrite existing commands
   * @return bool - true on succes, false on failure
   */
  public function alias($alias, $cmdline,$force = false) {
    return $this->getModule("cmd-alias")->addAlias($alias,$cmdline,$force);
  }
  //////////////////////////////////////////////////////////////
  // CmdBlowUp
  //////////////////////////////////////////////////////////////
  /**
   * Blow player up
   * @param Player $player - victim
   * @param int $yield - explosion power
   * @param bool $magic - don't affect blocks
   * @return bool - true on succes, false on failure
   */
  public function blowPlayer(Player $player,$yield,$magic = false) {
    return $this->getModule("blowup")->blowPlayer($player,$yield,$magic);
  }
  //////////////////////////////////////////////////////////////
  // CmdChatMgr
  //////////////////////////////////////////////////////////////
  /**
   * Enable/Disable Chat globally
   * @param bool $mode - true, chat is active, false, chat is disabled
   */
  public function setGlobalChat($mode) {
    $this->getModule("chat-utils")->setGlobalChat($mode);
  }
  /**
   * Returns global chat status
   * @return bool
   */
  public function getGlobalChat() {
    return $this->getModule("chat-utils")->getGlobalChat();
  }
  /**
   * Enable/Disable player's chat
   * @param Player $player
   * @param bool $mode - true, chat is active, false, chat is disabled
   */
  public function setPlayerChat(Player $player,$mode) {
    $this->getModule("chat-utils")->setPlayerChat($player,$mode);
  }
  /**
   * Returns player's chat status
   * @param Player $player
   * @return bool
   */
  public function getPlayerChat(Player $player) {
    return $this->getModule("chat-utils")->getPlayerChat($player);
  }
  //////////////////////////////////////////////////////////////
  // CmdFollowMgr
  //////////////////////////////////////////////////////////////
  /**
   * Returns players that are leading others
   * @return str[]
   */
  public function getLeaders() {
    return $this->getModule("followers")->getLeaders();
  }
  /**
   * Returns followers of a certain leader
   * @param Player $leader
   * @return str[]
   */
  public function getFollowers(Player $leader) {
    return $this->getModule("followers")->getFollowers($leader);
  }
  /**
   * Make a player follow another
   * @param Player $follower
   * @param Player $leader
   */
  public function follow(Player $follower, Player $leader) {
    $this->getModule("followers")->follow($follower,$leader);
  }
  /**
   * Stop a player from following
   * @param Player $follower
   */
  public function stopFollowing(Player $follower) {
    $this->getModule("followers")->stopFollowing($follower);
  }
  /**
   * Remove all folowers from a leader
   * @param Player $leader
   */
  public function stopLeading(Player $leader) {
    $this->getModule("followers")->stopLeading($leader);
  }
  //////////////////////////////////////////////////////////////
  // CmdMuteMgr
  //////////////////////////////////////////////////////////////
  /**
   * Returns the list of muted players
   * @return str[]
   */
  public function getMutes() {
    return $this->getModule("mute-unmute")->getMutes();
  }
  /**
   * Mute/UnMute a player
   * @param Player $player
   * @param bool $mode - true is muted, false is unmuted
   */
  public function setMute(Player $player,$mode) {
    $this->getModule("mute-unmute")->setMute($player, $mode);
  }
  /**
   * Returns a player mute status
   * @param Player $player
   * @return bool
   */
  public function getMute(Player $player) {
    return $this->getModule("mute-unmute")->getMute($player);
  }
  //////////////////////////////////////////////////////////////
  // CmdOpMsg
  //////////////////////////////////////////////////////////////
  /**
   * File a report
   * @param CommandSender $c
   * @param str $report
   */
  public function fileReport(CommandSender $c, $report) {
    $this->getModule("opms-rpt")->rptCmd($player, [ ">", $report]);
  }
  //////////////////////////////////////////////////////////////
  // CmdReOp
  //////////////////////////////////////////////////////////////
  /**
   * Return player's reop status
   * @param Player $target
   * @return bool
   */
  public function isReOp(Player $target) {
		return $this->getModule("reop")->isReOp($target);
	}
  /**
   * Toggle player's reop
   * @param Player $target
   */
	public function reopPlayer(Player $target) {
    $this->getModule("reop")->reopPlayer($target);
  }
  //////////////////////////////////////////////////////////////
  // CmdShieldMgr
  //////////////////////////////////////////////////////////////
  /**
   * Return player's shield status
   * @param Player $target
   * @return bool
   */
  public function isShielded(Player $target) {
		return $this->getModule("shield")->isShielded($target);
  }
  /**
   * Turn on/off shields
   * @param Player $target
   * @param bool $mode - true is shielded, false is not
   */
  public function setShield(Player $target, $mode) {
    $this->getModule("shield")->setShield($target, $mode);
  }
  //////////////////////////////////////////////////////////////
  // CmdSkinner
  //////////////////////////////////////////////////////////////
  /**
   * Returns a list of skins
   * @param str $folder - folder to search
   * @return str[]
   */
  public function getSkins($folder = null) {
		return $this->getModule("skinner")->getSkins($folder);
	}
  /**
   * Save a player's skin
   * @param Human $human - character to save
   * @param str $fn - file name
   * @param str $folder - folder to search
   * @return int - bytes written
   *
   */
	public function saveSkin(Human $human,$fn,$folder = null) {
    return $this->getModule("skinner")->saveSkin($human,$fn,$folder);
	}
  /**
   * Load a player's skin
   * @param Human $human - character to load
   * @param str $fn - file name
   * @param str $folder - folder to search
   * @return bool - true on succes, false on failure
   *
   */
	public function loadSkin(Human $human,$fn,$folder = null) {
    return $this->getModule("skinner")->loadSkin($human,$fn,$folder);
	}
  //////////////////////////////////////////////////////////////
  // CmdSlay
  //////////////////////////////////////////////////////////////
  /**
   * Kills a player with optional message
   * @param Player $victim
   * @param str $msg
   */
  public function slay(Player $victim, $msg = "") {
    $this->getModule("slay")->slay($victim,$msg);
  }
  //////////////////////////////////////////////////////////////
  // CmdSpawn
  //////////////////////////////////////////////////////////////
  /**
   * Teleport a player to world spawn
   * @param Player $player
   */
  public function tpSpawn(Player $player) {
    $this->getModule("spawn")->tpSpawn($player);
  }
  //////////////////////////////////////////////////////////////
  // CmdSrvMoDeMgr
  //////////////////////////////////////////////////////////////
  /**
   * Return the current service mode status
   * @return false|str
   */
  public function getServiceMode() {
    return $this->getModule("srvmode")->getServiceMode();
  }
  /**
   * Change the service mode
   * @param str $msg
   */
  public function setServiceMode($msg) {
    $this->getModule("srvmode")->setServiceMode($msg);
  }
  /**
   * Exists service mode
   */
  public function unsetServiceMode() {
    $this->getModule("srvmode")->unsetServiceMode();
  }
  //////////////////////////////////////////////////////////////
  // CmdSummon
  //////////////////////////////////////////////////////////////
  /**
   * Teleport a player to the summoner's vicinity
   * @param Player $summoner
   * @param Player $victim
   */
  public function summonPlayer(Player $summoner,Player $victim) {
    $this->getModule("summon-dismiss")->cmdSummon($summoner,[$victim->getName()]);
  }
  /**
   * Dismiss a previously summoned player
   * @param Player $summoner
   * @param Player $victim
   */
  public function dismissPlayer(Player $summoner,Player $victim) {
    $this->getModule("summon-dismiss")->cmdDismiss($summoner,[$victim->getName()]);
  }
  /**
   * Dismiss all summoned players
   * @param Player $summoner
   */
  public function dismissAll(Player $summoner) {
    $this->getModule("summon-dismiss")->cmdDismiss($summoner,["--all"]);
  }
  //////////////////////////////////////////////////////////////
  // CmdThrow
  //////////////////////////////////////////////////////////////
  /**
   * Throw player up in the air.
   * @param Player $victim
   */
  public function throwPlayer(Player $victim) {
    $this->getModule("throw")->throwPlayer($victim);
  }
  //////////////////////////////////////////////////////////////
  // CmdTpStack
  //////////////////////////////////////////////////////////////
  /**
   * Save position to stack
   * @param Player $player
   */
   public function pushTp(Player $player) {
     $this->getModule("pushtp-poptp")->cmdPushTp($player,[]);
   }
   /**
    * Restore position from stack
    * @param Player $player
    */
   public function popTp(Player $player) {
      $this->getModule("pushtp-poptp")->cmdPopTp($player,[]);
   }

  //////////////////////////////////////////////////////////////
  // ServerList
  //////////////////////////////////////////////////////////////
  /**
   * Get server ids
   */
  public function getServerIds() {
    return $this->getModule("ServerList")->getIds();
  }
  /**
   * Add Server
   * @param str $id - Server Id
   * @param array $attrs - Server attributes
   * @return bool - true on success, false on error
   */
  public function addServer($id,array $attrs) {
    return $this->getModule("ServerList")->addServer($id,$attrs);
  }
  /**
   * Remove Server
   * @param str $id - Server Id
   * @return bool - true on success, false on error
   */
  public function removeServer($id) {
    return $this->getModule("ServerList")->rmServer($id);
  }
  /**
   * Get Server attributes
   * @param str $id - Server Id
   * @return array - attributes
   */
  public function getServer($id) {
    return $this->getModule("ServerList")->getServer($id);
  }
  //
}
<?php
namespace aliuly\grabbag\common;

/**
 * Simple translation class in the style of **gettext**.
 *
 * You can actually use **gettext** tools to process these files.
 * For example, to create/update a message catalogue use:
 *
 * `xgettext --no-wrap [-j] [-o file]`
 *
 * Where -j is used to join an existing catalague.
 * -o file is the output file.
 *
 * Basic usage:
 *
 * * mc::load("messages.po|messages.ini");
 * * mc::plugin_init($plugin,$plugin->getFile());
 * * mc::_("string to translate\n")
 * * mc::_("string to translate %1% %2%\n",$arg1,$arg2)
 * * mc::n(mc::\_("singular form"),mc::\_("Plural form"),$count)
 */
abstract class mc {
	/** @var str[] $txt Message translations */
	public static $txt = [];
	/** Main translation function
	 *
	 * This translates strings.  The naming of "_" is to make it compatible
	 * with gettext utilities.  The string can contain "%1%", "%2%, etc...
	 * These are inserted from the following arguments.  Use "%%" to insert
	 * a single "%".
	 *
	 * @param str[] $args - messages
	 * @return str translated string
	 */
	public static function _(...$args) {
		$fmt = array_shift($args);
		if (isset(self::$txt[$fmt])) $fmt = self::$txt[$fmt];
		if (count($args)) {
			$vars = [ "%%" => "%" ];
			$i = 1;
			foreach ($args as $j) {
				$vars["%$i%"] = $j;
				++$i;
			}
			$fmt = strtr($fmt,$vars);
		}
		return $fmt;
	}
	/**
	 * Plural and singular forms.
	 *
	 * @param str $a - Singular form
	 * @param str $b - Plural form
	 * @param int $c - the number to test to select between $a or $b
	 * @return str - Either plural or singular forms depending on the value of $c
	 */
	public static function n($a,$b,$c) {
		return $c == 1 ? $a : $b;
	}
	/**
	 * Load a message file for a PocketMine plugin.  Only uses .ini files.
	 *
	 * @param Plugin $plugin - owning plugin
	 * @param str $path - output of $plugin->getFile()
	 * @return int|false - false on error or the number of messages loaded
	 */
	public static function plugin_init($plugin,$path) {
		if (file_exists($plugin->getDataFolder()."messages.ini")) {
			return self::load($plugin->getDataFolder()."messages.ini");
		}
		$msgs = $path."resources/messages/".
				$plugin->getServer()->getProperty("settings.language").
				".ini";
		if (!file_exists($msgs)) return false;
		return self::load($msgs);
	}

	/**
	 * Load the specified message catalogue.
	 * Can read .ini or .po files.
	 * @param str $f - Filename to load
	 * @return int|false - returns the number of strings loaded or false on error
	 */
	public static function load($f) {
		$potxt = "\n".file_get_contents($f)."\n";
		if (preg_match('/\nmsgid\s/',$potxt)) {
			$potxt = preg_replace('/\\\\n"\n"/',"\\n",
										 preg_replace('/\s+""\s*\n\s*"/'," \"",
														  $potxt));
		}
		foreach (['/\nmsgid "(.+)"\nmsgstr "(.+)"\n/',
					 '/^\s*"(.+)"\s*=\s*"(.+)"\s*$/m'] as $re) {
			$c = preg_match_all($re,$potxt,$mm);
			if ($c) {
				for ($i=0;$i<$c;++$i) {
					if ($mm[2][$i] == "") continue;
					eval('$a = "'.$mm[1][$i].'";');
					eval('$b = "'.$mm[2][$i].'";');
					self::$txt[$a] = $b;
				}
				return $c;
			}
		}
		return false;
	}
}
<?php
namespace aliuly\grabbag\common;
use pocketmine\item\Item;
use pocketmine\utils\TextFormat;
use pocketmine\utils\MainLogger;
use pocketmine\command\CommandSender;
use pocketmine\Player;

use aliuly\grabbag\common\mc;

/**
 * My PocketMine Utils class
 */
abstract class MPMU {
	/** @var str[] $items Nice names for items */
	static protected $items = [];
	/** @const str VERSION plugin version string */
	const VERSION = "1.90.0";

	/**
	 * libcommon library version.  If a version is provided it will check
	 * the version using apiCheck.
	 *
	 * @param str version Version to check
	 *
	 * @return str|bool
	 */
	static public function version($version = "") {
		if ($version == "") return self::VERSION;
		return self::apiCheck(self::VERSION,$version);
	}
	/**
	 * Used to check the PocketMine API version
	 *
	 * @param str version Version to check
	 *
	 * @return str|bool
	 */
	static public function apiVersion($version = "") {
		if ($version == "") return \pocketmine\API_VERSION;
		return self::apiCheck(\pocketmine\API_VERSION,$version);
	}
	/**
	 * Checks API compatibility from $api against $version.  $version is a
	 * string containing the version.  It can contain the following operators:
	 *
	 * >=, <=, <> or !=, =, !|~, <, >
	 *
	 * @param str api Installed API version
	 * @param str version API version to compare against
	 *
	 * @return bool
	 */
	static public function apiCheck($api,$version) {
		switch (substr($version,0,2)) {
			case ">=":
				return version_compare($api,trim(substr($version,2))) >= 0;
			case "<=":
				return version_compare($api,trim(substr($version,2))) <= 0;
			case "<>":
			case "!=":
				return version_compare($api,trim(substr($version,2))) != 0;
		}
		switch (substr($version,0,1)) {
			case "=":
				return version_compare($api,trim(substr($version,1))) == 0;
			case "!":
			case "~":
				return version_compare($api,trim(substr($version,1))) != 0;
			case "<":
				return version_compare($api,trim(substr($version,1))) < 0;
			case ">":
				return version_compare($api,trim(substr($version,1))) > 0;
		}
		if (intval($api) != intval($version)) return 0;
		return version_compare($api,$version) >= 0;
	}
	/**
	 * Returns a localized string for the gamemode
	 *
	 * @param int mode
	 * @return str
	 */
	static public function gamemodeStr($mode) {
		if (class_exists(__NAMESPACE__."\\mc",false)) {
			switch ($mode) {
				case 0: return mc::_("Survival");
				case 1: return mc::_("Creative");
				case 2: return mc::_("Adventure");
				case 3: return mc::_("Spectator");
			}
			return mc::_("%1%-mode",$mode);
		}
		switch ($mode) {
			case 0: return "Survival";
			case 1: return "Creative";
			case 2: return "Adventure";
			case 3: return "Spectator";
		}
		return "$mode-mode";
	}
	/**
	 * Check's player or sender's permissions and shows a message if appropriate
	 *
	 * @param CommandSender $sender
	 * @param str $permission
	 * @param bool $msg If false, no message is shown
	 * @return bool
	 */
	static public function access(CommandSender $sender, $permission,$msg=true) {
		if($sender->hasPermission($permission)) return true;
		if ($msg)
			$sender->sendMessage(mc::_("You do not have permission to do that."));
		return false;
	}
	/**
	 * Check's if $sender is a player in game
	 *
	 * @param CommandSender $sender
	 * @param bool $msg If false, no message is shown
	 * @return bool
	 */
	static public function inGame(CommandSender $sender,$msg = true) {
		if (!($sender instanceof Player)) {
			if ($msg) $sender->sendMessage(mc::_("You can only do this in-game"));
			return false;
		}
		return true;
	}
	/**
	 * Takes a player and creates a string suitable for indexing
	 *
	 * @param Player|str $player - Player to index
	 * @return str
	 */
	static public function iName($player) {
		if ($player instanceof Player) {
			$player = strtolower($player->getName());
		}
		return $player;
	}
	/**
	 * Lile file_get_contents but for a Plugin resource
	 *
	 * @param Plugin $plugin
	 * @param str $filename
	 * @return str|null
	 */
	static public function getResourceContents($plugin,$filename) {
		$fp = $plugin->getResource($filename);
		if($fp === null){
			return null;
		}
		$contents = stream_get_contents($fp);
		fclose($fp);
		return $contents;
	}
	/**
	 * Call a plugin's function.
	 *
	 * If the $plug parameter is given a string, it will simply look for that
	 * plugin.  If an array is provided, it is assumed to be of the form:
	 *
	 *   [ "plugin", "version" ]
	 *
	 * So then it will check that the plugin exists, and the version number
	 * matches according to the rules from **apiCheck**.
	 *
	 * Also, if plugin contains an **api** property, it will use that as
	 * the class for method calling instead.
	 *
	 * @param Server $server - pocketmine server instance
	 * @param str|array $plug - plugin to call
	 * @param str $method - method to call
	 * @param mixed $default - If the plugin does not exist or it is not enable, this value is returned
	 * @return mixed
	 */
	static public function callPlugin($server,$plug,$method,$args,$default = null) {
		$v = null;
		if (is_array($plug)) list($plug,$v) = $plug;
		if (($plugin = $server->getPluginManager()->getPlugin($plug)) === null
			 || $plugin->isEnabled()) return $default;

		if ($v !== null && !self::apiCheck($plugin->getDescription()->getVersion(),$v)) return $default;
		if (property_exists($plugin,"api")) {
			$fn = [ $plugin->api , $method ];
		} else {
			$fn = [ $plugin, $method ];
		}
		if (!is_callable($fn)) return $default;
		return $fn(...$args);
	}
	/**
	 * Register a command
	 *
	 * @param Plugin $plugin - plugin that "owns" the command
	 * @param CommandExecutor $executor - object that will be called onCommand
	 * @param str $cmd - Command name
	 * @param array $yaml - Additional settings for this command.
	 * @deprecated Moved to Cmd class
	 */
	static public function addCommand($plugin, $executor, $cmd, $yaml) {
		$newCmd = new \pocketmine\command\PluginCommand($cmd,$plugin);
		if (isset($yaml["description"]))
			$newCmd->setDescription($yaml["description"]);
		if (isset($yaml["usage"]))
			$newCmd->setUsage($yaml["usage"]);
		if(isset($yaml["aliases"]) and is_array($yaml["aliases"])) {
			$aliasList = [];
			foreach($yaml["aliases"] as $alias) {
				if(strpos($alias,":")!== false) {
					$this->owner->getLogger()->info("Unable to load alias $alias");
					continue;
				}
				$aliasList[] = $alias;
			}
			$newCmd->setAliases($aliasList);
		}
		if(isset($yaml["permission"]))
			$newCmd->setPermission($yaml["permission"]);
		if(isset($yaml["permission-message"]))
			$newCmd->setPermissionMessage($yaml["permission-message"]);
		$newCmd->setExecutor($executor);
		$cmdMap = $plugin->getServer()->getCommandMap();
		$cmdMap->register($plugin->getDescription()->getName(),$newCmd);
	}
	/**
	 * Unregisters a command
	 * @param Server|Plugin $obj - Access path to server instance
	 * @param str $cmd - Command name to remove
	 * @deprecated Moved to Cmd class
	 */
	static public function rmCommand($srv, $cmd) {
		$cmdMap = $srv->getCommandMap();
		$oldCmd = $cmdMap->getCommand($cmd);
		if ($oldCmd === null) return false;
		$oldCmd->setLabel($cmd."_disabled");
		$oldCmd->unregister($cmdMap);
		return true;
	}
	/**
	 * Send a PopUp, but takes care of checking if there are some
	 * plugins that might cause issues.
	 *
	 * Currently only supports SimpleAuth and BasicHUD.
	 *
	 * @param Player $player
	 * @param str $msg
	 */
	static public function sendPopup($player,$msg) {
		$pm = $player->getServer()->getPluginManager();
		if (($sa = $pm->getPlugin("SimpleAuth")) !== null) {
			// SimpleAuth also has a HUD when not logged in...
			if ($sa->isEnabled() && !$sa->isPlayerAuthenticated($player)) return;
		}
		if (($hud = $pm->getPlugin("BasicHUD")) !== null) {
			// Send pop-ups through BasicHUD
			$hud->sendPopup($player,$msg);
			return;
		}
		$player->sendPopup($msg);
	}
	/**
	 * Check prefixes
	 * @param str $txt - input text
	 * @param str $tok - keyword to test
	 * @return str|null
	 */
	static public function startsWith($txt,$tok) {
		$ln = strlen($tok);
		if (strtolower(substr($txt,0,$ln)) != $tok) return null;
		return trim(substr($txt,$ln));
	}


}
<?php
//= module:join-mgr
//: Announce joining ops, and show server motd
//:
//: This listener module will broadcast a message for ops joining
//: a server.
//:
//: Also, it will show the server's motd on connect.

namespace aliuly\grabbag;

use pocketmine\plugin\PluginBase as Plugin;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerJoinEvent;

use aliuly\grabbag\common\mc;

class JoinMgr implements Listener {
	public $owner;
	protected $admjoin;
	protected $srvmotd;
	static $delay = 15;

	static public function defaults() {
		//= cfg:join-mgr
		return [
			"# adminjoin" => "broadcast whenever an op joins",
			"adminjoin" => true,
			"# servermotd" => "show the server's motd when joining",
			"servermotd" => true,
		];
	}


	public function __construct(Plugin $plugin,$cfg) {
		$this->owner = $plugin;
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
		$this->admjoin = $cfg["adminjoin"];
		$this->srvmotd = $cfg["servermotd"];
	}
	public function onPlayerJoin(PlayerJoinEvent $e) {
		$pl = $e->getPlayer();
		if ($pl == null) return;
		if ($this->srvmotd) {
			$pl->sendMessage($this->owner->getServer()->getMotd());
		}
		if ($this->admjoin && $pl->isOp()) {
			$pn = $pl->getDisplayName();
			$this->owner->getServer()->broadcastMessage(mc::_("Server op $pn joined."));
		}
	}
}
<?php
//= module:broadcast-tp
//: Broadcast player teleports
//:
//: This listener module will broadcast when a player teleports to
//: another location.  It also generates some smoke and plays a sound.
//:

namespace aliuly\grabbag;

use pocketmine\plugin\PluginBase as Plugin;
use pocketmine\event\Listener;
use pocketmine\event\entity\EntityTeleportEvent;
use pocketmine\Player;
use pocketmine\level\Position;
use pocketmine\math\Vector3;
use pocketmine\level\particle\DustParticle;
use pocketmine\level\sound\FizzSound;

use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;

class BcTpMgr implements Listener {
	public $owner;
	protected $world;
	protected $local;

	static public function defaults() {
		//= cfg:broadcast-tp
		return [
			"# world" => "world broadcast setting.", // If true, will broadcast teleports accross worlds.
			"world" => true,
			"# local" => "local broadcast setting.", // This will broadcast teleports that go beyond this number.
			"local" => 500,
		];
	}
	protected static function randy($p,$r,$o) {
		return $p+(mt_rand()/mt_getrandmax())*$r-$o;
	}
	protected static function randVector(Vector3 $center) {
		return new Vector3(self::randy($center->getX(),0.5,-0.25),
								 self::randy($center->getY(),2,0),
								 self::randy($center->getZ(),0.5,-0.25));
	}

	public function __construct(Plugin $plugin,$cfg) {
		$this->owner = $plugin;
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
		$this->world = $cfg["world"];
		$this->local = $cfg["local"];
	}
	/**
	 * @priority MONITOR
	 */
	public function onTeleport(EntityTeleportEvent $ev) {
		if ($ev->isCancelled()) return;
		$pl = $ev->getEntity();
		if (!($pl instanceof Player)) return;
		$from = $ev->getFrom();
		if (!$from->getLevel()) $from->setLevel($pl->getLevel());
		$to = $ev->getTo();
		if (!$to->getLevel()) $to->setLevel($pl->getLevel());

		if (MPMU::apiVersion("1.12.0")) {
			foreach ([$to,$from] as $pos) {
				for ($i=0;$i<20;$i++) {
					$pos->getLevel()->addParticle(new DustParticle(self::randVector($pos),(mt_rand()/mt_getrandmax())*2,255,255,255));
				}
				$pos->getLevel()->addSound(new FizzSound($pos));
			}
		}

		if ($from->getLevel()->getName() != $to->getLevel()->getName()) {
			if ($this->world) {
				$this->owner->getServer()->broadcastMessage(
					mc::_("%1% teleported to %2%",
							$pl->getName(),
							$to->getLevel()->getName()));
			}
			return;
		}
		if (!$this->local) return;
		$dist = $from->distance($to);
		if ($dist > $this->local) {
			$this->owner->getServer()->broadcastMessage(
				mc::_("%1% teleported away!",$pl->getName()));
		}
	}
}
<?php
//= cmd:freeze|thaw,Trolling
//: freeze/unfreeze a player so they cannot move.
//> usage: **freeze|thaw** [ _player_ | **--hard|--soft** ]
//:
//: Stops players from moving.  If no player specified it will show
//: the list of frozen players.
//:
//: If **--hard** or **--soft** is specified instead of a player name, it
//: will change the freeze mode.


namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerMoveEvent;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

class CmdFreezeMgr extends BasicCli implements Listener,CommandExecutor {
	protected $frosties;
	protected $hard;

	//= cfg:freeze-thaw
	static public function defaults() {
		return [
			"# hard-freeze" => "how hard to freeze players.", // If **true** no movement is allowed.  If **false**, turning is allowed but not walking/running/flying, etc.
			"hard-freeze"=>false,
		];
	}

	public function isHardFreeze() {
		return $this->hard;
  }
  public function setHardFreeze($hard) {
		$this->hard = $hard ? true : false;
		$this->owner->cfgSave("freeze-thaw",["hard-freeze"=>$this->hard]);
  }
  public function freeze($player, $freeze) {
		$n = strtolower($player->getName());
		if ($freeze) {
			$this->frosties[$n] = $player->getName();
		} else {
			if (isset($this->frosties[$n])) unset($this->frosties[$n]);
		}
  }
  public function getFrosties() {
    return array_keys($this->frosties);
  }

	public function __construct($owner,$cfg) {
		parent::__construct($owner);
		$this->hard = $cfg["hard-freeze"];
		PermUtils::add($this->owner, "gb.cmd.freeze", "freeze/thaw players", "op");
		$this->enableCmd("freeze",
							  ["description" => mc::_("freeze player"),
								"usage" => mc::_("/freeze [--hard|--soft] [player]"),
								"permission" => "gb.cmd.freeze"]);
		$this->enableCmd("thaw",
							  ["description" => mc::_("thaw player"),
								"usage" => mc::_("/thaw [player]"),
								"aliases" => ["unfreeze"],
								"permission" => "gb.cmd.freeze"]);
		$this->frosties = [];
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if (count($args) == 0) {
			$sender->sendMessage(mc::_("Frozen: %1%",count($this->frosties)));
			if (count($this->frosties))
				$sender->sendMessage(implode(", ",$this->frosties));
			return true;
		}
		switch ($cmd->getName()) {
			case "freeze":
				if ($args[0] == "--hard") {
					$sender->sendMessage(mc::_("Now doing hard freeze"));
					$this->setHardFreeze(true);
					return true;
				} elseif ($args[0] == "--soft") {
					$sender->sendMessage(mc::_("Now doing soft freeze"));
					$this->setHardFreeze(false);
					return true;
				}

				foreach ($args as $n) {
					$player = $this->owner->getServer()->getPlayer($n);
					if ($player) {
						$this->frosties[strtolower($player->getName())] = $player->getName();
						$player->sendMessage(mc::_("You have been frozen by %1%",
															$sender->getName()));
						$sender->sendMessage(mc::_("%1% is frozen.",$n));
					} else {
						$sender->sendMessage(mc::_("%1% not found.",$n));
					}
				}
				return true;
			case "thaw":
				foreach ($args as $n) {
					if (isset($this->frosties[strtolower($n)])) {
						unset($this->frosties[strtolower($n)]);
						$player = $this->owner->getServer()->getPlayer($n);
						if ($player) {
							$player->sendMessage(mc::_("You have been thawed by %1%",
																$sender->getName()));
						}
						$sender->sendMessage(mc::_("%1% is thawed",$n));
					} else {
						$sender->sendMessage(mc::_("%1% not found or not thawed",$n));
					}
				}
				return true;
		}
		return false;
	}
	public function onMove(PlayerMoveEvent $ev) {
		if ($ev->isCancelled()) return;
		$p = $ev->getPlayer();
		if (isset($this->frosties[strtolower($p->getName())])) {
			if ($this->hard) {
				$ev->setCancelled();
				if (MPMU::apiVersion("1.12.0"))
					$p->sendTip(mc::_("You are frozen"));
			} else {
				// Lock position but still allow to turn around
				$to = clone $ev->getFrom();
				$to->yaw = $ev->getTo()->yaw;
				$to->pitch = $ev->getTo()->pitch;
				$ev->setTo($to);
				if (MPMU::apiVersion("1.12.0"))
					$p->sendTip(mc::_("You are frozen in place"));
			}
		}
	}
}
<?php
namespace aliuly\grabbag\common;

use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\command\PluginCommand;
use pocketmine\Player;

use pocketmine\utils\TextFormat;

/**
 * Implements Basic CLI common functionality.  It is useful for plugins
 * that implement multiple commands or sub-commands
 */
abstract class BasicCli {
	protected $owner;
	/**
	 * @param BasicPlugin @owner - Plugin that owns this module
	 */
	public function __construct($owner) {
		$this->owner = $owner;
	}
  /**
	 * Register this class as a sub-command.  See BasicPlugin for details.
	 *
	 * @param str $cmd - sub-command to register
	 * @param mixed[] $opts - additional options for registering sub-command
	 */
	public function enableSCmd($cmd,$opts) {
		$this->owner->registerScmd($cmd,[$this,"onSCommand"],$opts);
	}
	/**
	 * Register this class as a command.
	 *
	 * @param str $cmd - command to register
	 * @param mixed[] $yaml - options for command
	 */
	public function enableCmd($cmd,$yaml) {
		$newCmd = new PluginCommand($cmd,$this->owner);
		if (isset($yaml["description"]))
			$newCmd->setDescription($yaml["description"]);
		if (isset($yaml["usage"]))
			$newCmd->setUsage($yaml["usage"]);
		if(isset($yaml["aliases"]) and is_array($yaml["aliases"])) {
			$aliasList = [];
			foreach($yaml["aliases"] as $alias) {
				if(strpos($alias,":")!== false) {
					$this->owner->getLogger()->info("Unable to load alias $alias");
					continue;
				}
				$aliasList[] = $alias;
			}
			$newCmd->setAliases($aliasList);
		}
		if(isset($yaml["permission"]))
			$newCmd->setPermission($yaml["permission"]);
		if(isset($yaml["permission-message"]))
			$newCmd->setPermissionMessage($yaml["permission-message"]);
		$newCmd->setExecutor($this);
		$cmdMap = $this->owner->getServer()->getCommandMap();
		$cmdMap->register($this->owner->getDescription()->getName(),$newCmd);
	}
	/**
	 * Use for paginaged output implementation.
	 * This gets the player specified page number that we want to Display
	 *
	 * @param str[] $args - Passed arguments
	 * @return int page number
	 */
	protected function getPageNumber(array &$args) {
		$pageNumber = 1;
		if (count($args) && is_numeric($args[count($args)-1])) {
			$pageNumber = (int)array_pop($args);
			if($pageNumber <= 0) $pageNumber = 1;
		}
		return $pageNumber;
	}
	/**
	 * Use for paginaged output implementation.
	 * Shows a bunch of line in paginated output.
	 *
	 * @param CommandSender $sender - entity that we need to display text to
	 * @param int $pageNumber - page that we need to display
	 * @param str[] $txt - Array containing one element per output line
	 * @return bool true
	 */
	protected function paginateText(CommandSender $sender,$pageNumber,array $txt) {
		$hdr = array_shift($txt);
		if($sender instanceof ConsoleCommandSender){
			$sender->sendMessage( TextFormat::GREEN.$hdr.TextFormat::RESET);
			foreach ($txt as $ln) $sender->sendMessage($ln);
			return true;
		}
		$pageHeight = 5;
		$lineCount = count($txt);
		$pageCount = intval($lineCount/$pageHeight) + ($lineCount % $pageHeight ? 1 : 0);
		$hdr = TextFormat::GREEN.$hdr. TextFormat::RESET;
		if ($pageNumber > $pageCount) {
			$sender->sendMessage($hdr);
			$sender->sendMessage("Only $pageCount pages available");
			return true;
		}
		$hdr .= TextFormat::RED." ($pageNumber of $pageCount)";
		$sender->sendMessage($hdr);
		for ($ln = ($pageNumber-1)*$pageHeight;$ln < $lineCount && $pageHeight--;++$ln) {
			$sender->sendMessage($txt[$ln]);
		}
		return true;
	}
	/**
	 * Use for paginaged output implementation.
	 * Formats and paginates a table
	 *
	 * @param CommandSender $sender - entity that we need to display text to
	 * @param int $pageNumber - page that we need to display
	 * @param str[][] $txt - Array containing one element per cell
	 * @return bool true
	 */
	protected function paginateTable(CommandSender $sender,$pageNumber,array $tab) {
		$cols = [];
		for($i=0;$i < count($tab[0]);$i++) $cols[$i] = strlen($tab[0][$i]);
		foreach ($tab as $row) {
			for($i=0;$i < count($row);$i++) {
				if (($l=strlen($row[$i])) > $cols[$i]) $cols[$i] = $l;
			}
		}
		$txt = [];
		$fmt = "";
		foreach ($cols as $c) {
			if (strlen($fmt) > 0) $fmt .= " ";
			$fmt .= "%-".$c."s";
		}
		foreach ($tab as $row) {
			$txt[] = sprintf($fmt,...$row);
		}
		return $this->paginateText($sender,$pageNumber,$txt);
	}

	//////////////////////////////////////////////////////////////////////
	/**
   * Entry point for BasicPlugin state functionality.  This makes it module
	 * specific.
	 * Retrieves the state.
	 *
	 * @param CommandSender $player - entity that we need state from
	 * @param mixed $default - Default value to return if no state found
	 * @return mixed $state
	 */
	public function getState(CommandSender $player,$default) {
		return $this->owner->getState(get_class($this),$player,$default);
	}
	/**
   * Entry point for BasicPlugin state functionality.  This makes it module
	 * specific.
	 * Sets the state.
	 *
	 * @param CommandSender $player - entity that we need to set state
	 * @param mixed $val - Value to use for the state
	 */
	public function setState(CommandSender $player,$val) {
		$this->owner->setState(get_class($this),$player,$val);
	}
	/**
   * Entry point for BasicPlugin state functionality.  This makes it module
	 * specific.
	 * UnSets the state.
	 *
	 * @param CommandSender $player - entity that we need to unset state
	 */
	public function unsetState(CommandSender $player) {
		$this->owner->unsetState(get_class($this),$player);
	}
}
<?php
//= module:cmd-selector
//: Implements "@" command prefixes
//:
//: Please refer to the CommandSelector section
//


namespace aliuly\grabbag;

use pocketmine\event\Listener;
use pocketmine\Player;
use pocketmine\entity\Entity;
use pocketmine\command\CommandSender;

use pocketmine\event\player\PlayerCommandPreprocessEvent;
use pocketmine\event\server\RemoteServerCommandEvent;
use pocketmine\event\server\ServerCommandEvent;
use pocketmine\event\Timings;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\CmdSelector;
use aliuly\grabbag\common\PermUtils;

class PlayerCommandPreprocessEvent_sub extends PlayerCommandPreprocessEvent{
}
class RemoteServerCommandEvent_sub extends RemoteServerCommandEvent{
}
class ServerCommandEvent_sub extends ServerCommandEvent{
}


class CmdSelMgr extends BasicCli implements Listener {
  protected $max;
	static public function defaults() {
		//= cfg:cmd-selector
		return [
			"# max-commands" => "Limit the ammount of commands generated by @ prefixes",
			"max-commands" => 100,
		];
	}
	public function __construct($owner, $cfg) {
		parent::__construct($owner);
		$this->max = $cfg["max-commands"];
    PermUtils::add($this->owner, "gb.module.cmdsel", "use command selectors", "true");
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
	}
	/**
	 * @priority HIGHEST
	 */
	public function onPlayerCmd(PlayerCommandPreprocessEvent $ev) {
		if ($ev instanceof PlayerCommandPreprocessEvent_sub) return;
		$line = $ev->getMessage();
		if(substr($line, 0, 1) !== "/") return;
		if (!$ev->getPlayer()->hasPermission("gb.module.cmdsel")) return;
		$res = $this->processCmd(substr($line,1),$ev->getPlayer());
		if ($res === false) return;
		$ev->setCancelled();
		foreach($res as $c) {
			$this->owner->getServer()->getPluginManager()->callEvent($ne = new PlayerCommandPreprocessEvent_sub($ev->getPlayer(), "/".$c));
			if($ne->isCancelled()) continue;
			if (substr($ne->getMessage(),0,1) !== "/") continue;
			$this->owner->getServer()->dispatchCommand($ne->getPlayer(), substr($ne->getMessage(),1));
		}
	}
	/**
	 * @priority HIGHEST
	 */
	public function onRconCmd(RemoteServerCommandEvent $ev) {
		if ($ev instanceof RemoteServerCommandEvent_sub) return;
		$res = $this->processCmd($ev->getCommand(),$ev->getSender());
		if ($res === false) return;
		$ev->setCancelled();
		foreach($res as $c) {
			$this->owner->getServer()->getPluginManager()->callEvent($ne = new RemoteServerCommandEvent_sub($ev->getSender(), $c));
			if($ne->isCancelled()) continue;
			$this->owner->getServer()->dispatchCommand($ne->getSender(), $ne->getCommand());
		}
	}
	/**
	 * @priority HIGHEST
	 */
	public function onConsoleCmd(ServerCommandEvent $ev) {
		if ($ev instanceof ServerCommandEvent_sub) return;
		$res = $this->processCmd($ev->getCommand(),$ev->getSender());
		if ($res === false) return;
		$ev->setCancelled();
		foreach($res as $c) {
			$this->owner->getServer()->getPluginManager()->callEvent($ne = new ServerCommandEvent_sub($ev->getSender(), $c));
			if($ne->isCancelled()) continue;
			$this->owner->getServer()->dispatchCommand($ne->getSender(), $ne->getCommand());
		}
	}

	protected function processCmd($cmd,CommandSender $sender) {
		return CmdSelector::expandSelectors($this->owner->getServer(),$sender, $cmd, $this->max);
	}
}
<?php
//= cmd:ops,Informational
//: Shows who are the ops on this server.
//> usage: **ops**

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\Player;
use pocketmine\utils\TextFormat;

use aliuly\grabbag\common\PermUtils;
use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;

class CmdOps extends BasicCli implements CommandExecutor {
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.ops", "Display ops", "true");
		$this->enableCmd("ops",
							  ["description" => mc::_("show ops and their on-line status"),
								"usage" => mc::_("/ops"),
								"permission" => "gb.cmd.ops"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "ops") return false;

		$txt = [ "" ];
		$pageNumber = $this->getPageNumber($args);
		$cnt=0;
		foreach (array_keys($this->owner->getServer()->getOps()->getAll()) as $opname) {
			$p = $this->owner->getServer()->getPlayer($opname);
			if($p && ($p->isOnline() && (!($sender instanceof Player) || $sender->canSee($p)))){
				++$cnt;
				$txt[] = TextFormat::BLUE.mc::_("%1% (online)",$opname);
			}else{
				$txt[] = TextFormat::RED."$opname";
			}
		}
		$txt[0] = mc::_("Server Ops (Online:%1%)",$cnt);
		return $this->paginateText($sender,$pageNumber,$txt);
	}
}
<?php
namespace aliuly\grabbag\common;

use pocketmine\plugin\Plugin;
use pocketmine\permission\Permission;

/**
 * Simple class encapsulating some Permission related utilities
 */
abstract class PermUtils {
  /**
   * Register a permission on the fly...
   * @param Plugin $plugin - owning plugin
   * @param str $name - permission name
   * @param str $desc - permission description
   * @param str $default - one of true,false,op,notop
   */
  static public function add(Plugin $plugin, $name, $desc, $default) {
    $perm = new Permission($name,$desc,$default);
    $plugin->getServer()->getPluginManager()->addPermission($perm);
  }
}
<?php
//= cmd:as,Player_Management
//: run command as somebody else
//> usage: **as** _<player>_ _<command>_
namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

use pocketmine\Player;
use pocketmine\event\player\PlayerChatEvent;

class CmdAs extends BasicCli implements CommandExecutor {

	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.sudo", "Run command as another user", "op");
		$this->enableCmd("as",
							  ["description" => mc::_("execute command as somebody else"),
								"usage" => mc::_("/as <player> <cmd>"),
								"aliases" => ["sudo"],
								"permission" => "gb.cmd.sudo"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "as") return false;
		if (count($args) < 2) {
			$sender->sendMessage(mc::_("Must specified a player and a command"));
			return false;
		}
		$player = $this->owner->getServer()->getPlayer($n = array_shift($args));
		if (!$player) {
			$sender->sendMessage(mc::_("Player %1% not found",$n));
			return true;
		}
		if ($args[0] == 'chat' || $args[0] == 'say') {
			array_shift($args);
			$chat = implode(" ",$args);
			$this->owner->getServer()->getPluginManager()->callEvent($ev = new PlayerChatEvent($player,$chat));
			if (!$ev->isCancelled()) {
				if (MPMU::apiVersion("1.12.0")) {
					$s = $this->owner->getServer();
					$s->broadcastMessage($s->getLanguage()->translateString(
						$ev->getFormat(),
						[$ev->getPlayer()->getDisplayName(), $ev->getMessage()]),
												$ev->getRecipients());
				} else {
					$this->owner->getServer()->broadcastMessage(sprintf(
						$ev->getFormat(),
						$ev->getPlayer()->getDisplayName(),
						$ev->getMessage()),$ev->getRecipients());
				}
			}
		} else {
			$cmdline = implode(' ',$args);
			$sender->sendMessage(mc::_("Running command as %1%",$n));
			$this->owner->getServer()->dispatchCommand($player,$cmdline);
		}
		return true;
	}
}
<?php
//= cmd:slay,Trolling
//: Kills the specified player
//> usage: **slay** _<player>_ _[messsage]_
//: Kills a player with an optional _message_.
namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\event\Listener;
use pocketmine\event\player\PlayerDeathEvent;
use pocketmine\utils\TextFormat;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PermUtils;

class CmdSlay extends BasicCli implements CommandExecutor,Listener {

	public function __construct($owner) {
		parent::__construct($owner);
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);

		PermUtils::add($this->owner, "gb.cmd.slay", "Allow slaying players", "op");

		$this->enableCmd("slay",
							  ["description" => mc::_("kill a player with optional message"),
								"usage" => mc::_("/slay <player> [message]"),
								"permission" => "gb.cmd.slay"]);
	}
	public function slay($victim, $msg = "") {
		if ($msg == "") {
			$this->unsetState($victim);
		} else {
			$this->setState($victim,[time(),$msg]);
		}
		$victim->setHealth(0);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "slay") return false;
		if (!isset($args[0])) {
			$sender->sendMessage(mc::_("Must specify a player to slay"));
			return false;
		}
		$victim = $this->owner->getServer()->getPlayer($n = array_shift($args));
		if ($victim == null) {
			$sender->sendMessage(mc::_("Player %1% not found",$n));
			return true;
		}
		$this->slay($victim,implode(" ",$args));
		$sender->sendMessage(TextFormat::RED.mc::_("%1% has been slain.",$victim->getName()));
		return true;
	}
	/**
	 * @priority LOW
	 */
	public function onPlayerDeath(PlayerDeathEvent $e) {
		list($timer,$msg) = $this->getState($e->getEntity(),[0,""]);
		if (time() - $timer > 1) return;
		$e->setDeathMessage($msg);
		$this->unsetState($e->getEntity());
	}
}
<?php
//= cmd:whois,Informational
//: Gives detailed information on players
//> usage: **whois** _<player>_
namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\Player;
use pocketmine\utils\TextFormat;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\MoneyAPI;
use aliuly\grabbag\common\PermUtils;

class CmdWhois extends BasicCli implements CommandExecutor {

	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.whois", "view players details", "op");
		PermUtils::add($this->owner, "gb.cmd.whois.showip", "view players IP address", "op");
		$this->enableCmd("whois",
							  ["description" => mc::_("show players detail info"),
								"usage" => "/whois <player>",
								"permission" => "gb.cmd.whois"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "whois") return false;
		$pageNumber = $this->getPageNumber($args);
		if (count($args) != 1) {
			$sender->sendMessage(mc::_("You must specify a player's name"));
			return true;
		}
		$target = $this->owner->getServer()->getPlayer($args[0]);
		if($target == null) {
			$target = $this->owner->getServer()->getOfflinePlayer($args[0]);
			if ($target == null || !$target->hasPlayedBefore()) {
				$sender->sendMessage(mc::_("%1% can not be found.",$args[0]));
				return true;
			}
		}
		$txt = [];
		$txt[] = TextFormat::AQUA.mc::_("About %1%",$args[0]);

		$txt[] = TextFormat::GREEN.mc::_("On-Line: ").TextFormat::WHITE
					 . ($target->isOnline() ? mc::_("YES") : mc::_("NO"));

		if ($target instanceof Player) {
			$txt[] = TextFormat::GREEN.mc::_("Health: ").TextFormat::WHITE
					 ."[".$target->getHealth()."/".$target->getMaxHealth()."]";
			$txt[] = TextFormat::GREEN.mc::_("World: ").TextFormat::WHITE
					 .$target->getLevel()->getName();

			$txt[] = TextFormat::GREEN.mc::_("Location: ").TextFormat::WHITE."X:".floor($target->getPosition()->x)." Y:".floor($target->getPosition()->y)." Z:".floor($target->getPosition()->z);
			if ($sender->hasPermission("gb.cmd.whois.showip"))
				$txt[] = TextFormat::GREEN.mc::_("IP Address: ").TextFormat::WHITE.$target->getAddress();
			$txt[] = TextFormat::GREEN.mc::_("Gamemode: ").TextFormat::WHITE
					 .MPMU::gamemodeStr($target->getGamemode());
			$txt[] = TextFormat::GREEN.mc::_("Display Name: ").TextFormat::WHITE
					 . $target->getDisplayName();
			$txt[] = TextFormat::GREEN.mc::_("Flying: ").TextFormat::WHITE
					 . ($target->isOnGround() ? mc::_("NO") : mc::_("YES"));
			//1.5
			if (MPMU::apiVersion("1.12.0")) {
				$txt[] = TextFormat::GREEN.mc::_("UUID: ").TextFormat::WHITE
						 . $target->getUniqueId();
				$txt[] = TextFormat::GREEN.mc::_("ClientID: ").TextFormat::WHITE
						 . $target->getClientId();
				$txt[] = TextFormat::GREEN.mc::_("Can Fly: ").TextFormat::WHITE
						 . ($target->getAllowFlight() ? mc::_("YES") : mc::_("NO") );

			}

		} else {
			$txt[] = TextFormat::GREEN.mc::_("Banned: ").TextFormat::WHITE
					 . ($target->isBanned() ? mc::_("YES") : mc::_("NO"));
		}
		$txt[] = TextFormat::GREEN.mc::_("Whitelisted: ").TextFormat::WHITE
				 . ($target->isWhitelisted() ? mc::_("YES") : mc::_("NO"));
		$txt[] = TextFormat::GREEN.mc::_("Opped: ").TextFormat::WHITE
				 . ($target->isOp() ? mc::_("YES") : mc::_("NO"));

		$txt[] = TextFormat::GREEN.mc::_("First Played: ").TextFormat::WHITE
				 . date(mc::_("d-M-Y H:i"),$target->getFirstPlayed()/1000);
		if ($target->getLastPlayed()) {
			$txt[] = TextFormat::GREEN.mc::_("Last Played: ").TextFormat::WHITE
					 . date(mc::_("d-M-Y H:i"),$target->getLastPlayed()/1000);
		}

		$pm = $this->owner->getServer()->getPluginManager();
		if (($kr = $pm->getPlugin("KillRate")) !== null) {
			if (version_compare($kr->getDescription()->getVersion(),"1.1") >= 0) {
				if (intval($kr->getDescription()->getVersion()) == 2) {
					$score = $kr->api->getScore($target);
				} else {
					$score = $kr->getScore($target);
				}
				if ($score)
					$txt[] = TextFormat::GREEN.mc::_("KillRate Score: ").TextFormat::WHITE.$score;
			} else {
				$txt[] = TextFormat::RED.mc::_("KillRate version is too old (%1%)",
														 $kr->getDescription()->getVersion());
			}
		}
		if (($pp = $pm->getPlugin("PurePerms")) !== null) {
			$txt[] = TextFormat::GREEN.mc::_("PurePerms Group: ").TextFormat::WHITE.$pp->getUser($target)->getGroup()->getName();
		}
		if (($sa = $pm->getPlugin("SimpleAuth")) !== null) {
			if ($target instanceof Player) {
				$txt[] = TextFormat::GREEN.mc::_("Authenticated: ").TextFormat::WHITE
						 . ($sa->isPlayerAuthenticated($target) ? mc::_("YES") : mc::_("NO"));
			}
			$txt[] = TextFormat::GREEN.mc::_("Registered: ").TextFormat::WHITE
					 . ($sa->isPlayerRegistered($target) ? mc::_("YES") : mc::_("NO"));
		}
		$money = MoneyAPI::moneyPlugin($this->owner);
		if ($money !== null) {
			$txt[]=TextFormat::GREEN.mc::_("Money: ").TextFormat::WHITE.
				MoneyAPI::getMoney($money,$target->getName()).
				TextFormat::AQUA.mc::_(" (from %1%)",$money->getFullName());
		}
		return $this->paginateText($sender,$pageNumber,$txt);
	}
}
<?php
//= cmd:mute|unmute,Trolling
//: mutes/unmutes a player so they can not use chat
//> usage: **mute|unmute** _[player]_
//:
//: Stops players from chatting.  If no player specified it will show
//: the list of muted players.

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerChatEvent;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PermUtils;


class CmdMuteMgr extends BasicCli implements Listener,CommandExecutor {
	protected $mutes;

	public function __construct($owner) {
		parent::__construct($owner);

		PermUtils::add($this->owner, "gb.cmd.mute", "mute/unmute players", "op");

		$this->enableCmd("mute",
							  ["description" => mc::_("mute player"),
								"usage" => mc::_("/mute [player]"),
								"permission" => "gb.cmd.mute"]);
		$this->enableCmd("unmute",
							  ["description" => mc::_("unmute player"),
								"usage" => mc::_("/unmute [player]"),
								"permission" => "gb.cmd.mute"]);
		$this->mutes = [];
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if (count($args) == 0) {
			$sender->sendMessage(mc::_("Mutes: %1%",count($this->mutes)));
			if (count($this->mutes))
				$sender->sendMessage(implode(", ",$this->mutes));
			return true;
		}
		switch ($cmd->getName()) {
			case "mute":
				foreach ($args as $n) {
					$player = $this->owner->getServer()->getPlayer($n);
					if ($player) {
						$this->mutes[strtolower($player->getName())] = $player->getName();
						$player->sendMessage(mc::_("You have been muted by %1%",
															$sender->getName()));
						$sender->sendMessage(mc::_("%1% is muted.",$n));
					} else {
						$sender->sendMessage(mc::_("%1% not found.",$n));
					}
				}
				return true;
			case "unmute":
				foreach ($args as $n) {
					if (isset($this->mutes[strtolower($n)])) {
						unset($this->mutes[strtolower($n)]);
						$player = $this->owner->getServer()->getPlayer($n);
						if ($player) {
							$player->sendMessage(mc::_("You have been unmuted by %1%",
																$sender->getName()));
						}
						$sender->sendMessage(mc::_("%1% is un-muted",$n));
					} else {
						$sender->sendMessage(mc::_("%1% not found or not muted",$n));
					}
				}
				return true;
		}
		return false;
	}
	public function getMutes() {
		return array_keys($this->mutes);
	}
	public function setMute($player,$mode) {
		$n = strtolower($player->getName());
		if ($mode) {
			if (isset($this->mutes[$n])) return;
			$this->mutes[$n] = $player->getName();
		} else  {
			if (!isset($this->mutes[$n])) return;
			unset($this->mutes[$n]);
		}
	}
	public function getMute($player) {
		return isset($this->mutes[strtolower($player->getName())]);
	}

	public function onChat(PlayerChatEvent $ev) {
		if ($ev->isCancelled()) return;
		$p = $ev->getPlayer();
		if (isset($this->mutes[strtolower($p->getName())])) {
			$p->sendMessage(mc::_("You have been muted!"));
			$ev->setCancelled();
		}
	}
}
<?php
//= cmd:showtimings,Informational
//: Shows timing repots as reported by **timings**
//> usage: **timings** _[t#]_
//:
//: If nothing specified it will list available reports.  These are
//: of the form of **timings.txt** or `timings1.txt`.
//:
//: To specify a report enter **t** for **timings.txt** or **t1** for
//: **timings1.txt**.
namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\utils\TextFormat;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PermUtils;

class CmdTimings extends BasicCli implements CommandExecutor {
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.timings", "view timings report", "op");
		$this->enableCmd("showtimings",
							  ["description" => mc::_("Show timings data (see /timings)"),
								"usage" => mc::_("/showtimings [t#]"),
								"aliases" => ["who"],
								"permission" => "gb.cmd.timings"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "showtimings") return false;
		$pageNumber = $this->getPageNumber($args);
		if (count($args)) {
			// Show the specified report
			$rpt = array_shift($args);
			if ($rpt == "clear") {
				$count = 0;
				foreach (glob($this->owner->getServer()->getDataPath(). "timings/timings*.txt") as $f) {
					unlink($f); $count++;
				}
				$sender->sendMessage(mc::_("Deleted reports: %1%",$count));
				return true;
			}
			$rpt = preg_replace('/[^0-9]+/i','',$rpt);
			$f = $this->owner->getServer()->getDataPath()."timings/timings$rpt.txt";
			if (!file_exists($f)) {
				$sender->sendMessage(mc::_("Report %1% can not be found.",$rpt));
				return true;
			}
			$txt = file($f);
			array_unshift($txt,mc::_("Report: timings%1%",$rpt));
			return $this->paginateText($sender,$pageNumber,$txt);
		}
		$txt = ["HDR"];
		// Inventorise the reports
		$count = 0;
		foreach (glob($this->owner->getServer()->getDataPath(). "timings/timings*.txt") as $f) {
			++$count;
			$txt[] = "- ".basename($f);
		}
		if ($count == 0) {
			$sender->sendMessage(TextFormat::RED.mc::_("No timmings report found"));
			$sender->sendMessage(mc::_("Enable timings by typing /timings on"));
			$sender->sendMessage(mc::_("Generate timings report by typing /timings report"));
			return true;
		}
		$txt[0] = mc::_("Reports: %1%",$count);
		return $this->paginateText($sender,$pageNumber,$txt);
	}
}
<?php
//= cmd:seeinv,Inventory_Management
//: Show player's inventory
//> usage: **seeinv** _<player>_
//= cmd:seearmor,Inventory_Management
//: Show player's armor
//> usage: **seearmor** _<player>_
namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\utils\TextFormat;
use pocketmine\item\Item;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\ItemName;
use aliuly\grabbag\common\PermUtils;

class CmdShowInv extends BasicCli implements CommandExecutor {
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.seearmor", "View armor", "op");
		PermUtils::add($this->owner, "gb.cmd.seeinv", "View inventory", "op");
		$this->enableCmd("seeinv",
							  ["description" => mc::_("show player's inventory"),
								"usage" => mc::_("/seeinv <player>"),
								"aliases" => ["invsee"],
								"permission" => "gb.cmd.seeinv"]);
		$this->enableCmd("seearmor",
							  ["description" => mc::_("show player's armor"),
								"usage" => mc::_("/seearmor <player>"),
								"aliases" => ["armorsee"],
								"permission" => "gb.cmd.seearmor"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		$pageNumber = $this->getPageNumber($args);
		if (count($args) != 1) {
			$sender->sendMessage(mc::_("You must specify a player's name"));
			return false;
		}
		$target = $this->owner->getServer()->getPlayer($args[0]);
		if($target == null) {
			$sender->sendMessage(mc::_("%1% can not be found.",$args[0]));
			return true;
		}
		if ($cmd->getName() == "seeinv") {
			$tab= [[$args[0],mc::_("Count"),mc::_("Damage")]];
			$max = $target->getInventory()->getSize();
			foreach ($target->getInventory()->getContents() as $slot => &$item) {
				if ($slot >= $max) continue;
				$tab[] = [ItemName::str($item)." (".$item->getId().")",
							 $item->getCount(),$item->getDamage() ];
			}
			if (count($tab) == 1) {
				$sender->sendMessage(mc::_("The inventory for %1% is EMPTY",$args[0]));
				return true;
			}
		}elseif ($cmd->getName() == "seearmor") {
			$tab= [[mc::_("Armor for"),TextFormat::RED.$args[0]]];
			foreach ([0=>"head",1=>"body",2=>"legs",3=>"boots"] as $slot=>$attr) {
				$item = $target->getInventory()->getArmorItem($slot);
				if ($item->getID() == 0) continue;
				$tab[]=[$attr.TextFormat::BLUE,
						  ItemName::str($item)." (" .$item->getId().":".$item->getDamage().")"];
			}
		}
		return $this->paginateTable($sender,$pageNumber,$tab);
	}
}
<?php
//= cmd:get,Inventory_Management
//: obtain an item
//> usage: **get** _<item>_ _[count]_
//:
//: This is a shortcut to **give** that lets player get items for
//: themselves.  You can replace **item** with **more** and the
//: current held item will be duplicated.

//= cmd:gift,Inventory_Management
//: give an item to a player
//> usage: **gift** _[player]_ _<item>_ _[count]_
//:
//: This is a re-implementation of **give** command.

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\utils\TextFormat;
use pocketmine\item\Item;
use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\ItemName;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

class CmdGet extends BasicCli implements CommandExecutor {
	// Override the MaxStacks counter...
	static $stacks = [
		Item::MINECART => 1, Item::BOOK => 1, Item::COMPASS => 1,
		Item::CLOCK => 1, Item::SPAWN_EGG => 1, Item::FURNACE => 1,
		Item::CHEST => 16, Item::TORCH => 16, Item::NETHER_REACTOR => 16,
	];

	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.get", "get blocks", "op");
		$this->enableCmd("get",
							  ["description" => mc::_("Shortcut to /give me"),
								"usage" => mc::_("/get <item[:damage]> [amount]"),
								"permission" => "gb.cmd.get"]);
		$this->enableCmd("gift",
							  ["description" => mc::_("Alternate /give implementation"),
								"usage" => mc::_("/gift <player <item[:damage]>> [amount]"),
								"permission" => "gb.cmd.get"]);

	}

	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if (!isset($args[0])) return false;
		if ($cmd->getName() == "gift") {
			if (($receiver = $this->owner->getServer()->getPlayer($args[0])) == null) {
				if (!MPMU::inGame($sender)) return true;
				$receiver= $sender;
			} else {
				array_shift($args);
			}
		} else {
			if (!MPMU::inGame($sender)) return true;
			$receiver = $sender;
		}

		if ($receiver->isCreative()) {
			if ($receiver === $sender)
				$receiver->sendMessage(mc::_("You are in creative mode"));
			else
				$sender->sendMessage(mc::_("%1% is in creative mode", $receiver->getDisplayName()));
			return true;
		}

		if (count($args) > 1 && is_numeric($args[count($args)-1])) {
			$amt = (int)array_pop($args);
		} else {
			$amt = -1;
		}

		$args = strtolower(implode("_",$args));
		if ($args == "more") {
			$item = clone $receiver->getInventory()->getItemInHand();
			if ($item->getId() == 0) {
				$sender->sendMessage(TextFormat::RED.
															mc::_("Must be holding something"));
				return true;
			}
		} else {
			$item = Item::fromString($args);
			if ($item->getId() == 0) {
				$sender->sendMessage(TextFormat::RED.
										mc::_("There is no item called %1%",$args));
				return true;
			}
		}

		if ($amt != -1) {
			$item->setCount($amt);
		} else {
			if (isset(self::$stacks[$item->getId()])) {
				$item->setCount(self::$stacks[$item->getId()]);
			} else {
				$item->setCount($item->getMaxStackSize());
			}
		}
		$receiver->getInventory()->addItem(clone $item);
		$this->owner->getServer()->broadcastMessage(
			mc::_("%1% got %2% of %3% (%4%:%5%)",
					$receiver->getDisplayName(),
					$item->getCount(),ItemName::str($item),
					$item->getId(),$item->getDamage()));
		return true;
	}
}
<?php
//= cmd:shield,Player_Management
//: player is protected from taking damage
//> usage: **shield**
//:
//: This will toggle your shield status.

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\event\Listener;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\Player;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

class CmdShieldMgr extends BasicCli implements Listener,CommandExecutor {
	public function __construct($owner) {
		parent::__construct($owner);

		PermUtils::add($this->owner, "gb.cmd.shield", "Allow players to become invulnverable", "op");
		$this->enableCmd("shield",
							  ["description" => mc::_("makes player invulnerable"),
								"usage" => mc::_("/shield"),
								"permission" => "gb.cmd.shield"]);
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
	}
	public function isShielded($player) {
		return $this->getState($player,false);
	}
	public function setShield($player, $mode) {
		if ($mode) {
			$this->setState($player,true);
		} else {
			$this->unsetState($player);
		}
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if (count($args) !== 0) return false;
		if ($cmd->getName() != "shield") return false;
		if (!MPMU::inGame($sender)) return true;
		$state = $this->getState($sender,false);
		if ($state) {
			$sender->sendMessage(mc::_("Shields DOWN"));
			$this->unsetState($sender);
		} else {
			$sender->sendMessage(mc::_("Shields UP"));
			$this->setState($sender,true);
		}
		return true;
	}

	public function onDamage(EntityDamageEvent $ev) {
		if ($ev->isCancelled()) return;
		if(!($ev instanceof EntityDamageByEntityEvent)) return;
		if (!($ev->getEntity() instanceof Player)) return;
		if (!$this->getState($ev->getEntity(),false)) return;
		$ev->setCancelled();
	}
}
<?php
//= cmd:servicemode,Server_Management
//: controls servicemode
//> usage: **servicemode** **[on|off** _[message]_ **]**
//:
//: If **on** it will activate service mode.  In service mode new
//: players can not join (unless they are ops).  Existing players
//: can remain but may be kicked manually by any ops.
namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\event\Listener;

use pocketmine\event\player\PlayerJoinEvent;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PluginCallbackTask;
use aliuly\grabbag\common\PermUtils;


class CmdSrvModeMgr extends BasicCli implements CommandExecutor,Listener {
	protected $mode;
	static $delay = 5;
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.servicemode", "service mode command", "op");
		PermUtils::add($this->owner, "gb.servicemode.allow", "login when in service mode", "op");

		$this->enableCmd("servicemode",
							  ["description" => mc::_("Enter/Exit servicemode"),
								"usage" => mc::_("/servicemode [on|off [message]]"),
								"aliases" => ["srvmode","srmode"],
								"permission" => "gb.cmd.servicemode"]);
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
		$this->mode = false;
	}
	public function getServiceMode() {
		return $this->mode;
	}
	public function setServiceMode($msg) {
		$this->mode = $msg;
	}
	public function unsetServiceMode() {
		$this->mode = false;
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "servicemode") return false;
		if (count($args) == 0) {
			if ($this->getServiceMode() !== false) {
				$sender->sendMessage(TextFormat::RED.mc::_("In Service Mode: %1%",$this->getServiceMode()));
			} else {
				$sender->sendMessage(TextFormat::GREEN.mc::_("In Normal operating mode"));
			}
			return true;
		}
		if (in_array(strtolower(array_shift($args)),["on","up","true",1])) {
			$msg = implode(" ",$args);
			if (!$msg) $msg = mc::_("Scheduled maintenance");
			$this->owner->getServer()->broadcastMessage(TextFormat::RED.mc::_("ATTENTION: Entering service mode"));
			$this->owner->getServer()->broadcastMessage(TextFormat::YELLOW." - ".$msg);
			$this->setServiceMode($msg);
		} else {
			$this->owner->getServer()->broadcastMessage(TextFormat::GREEN.mc::_("ATTENTION: Leaving service mode"));
			$this->unsetServiceMode();
		}
		return true;
	}
	//
	// Event handlers...
	//
	public function onPlayerJoin(PlayerJoinEvent $e) {
		$pl = $e->getPlayer();
		if ($pl == null) return;
		if ($this->mode === false) return;
		if ($pl->hasPermission("gb.servicemode.allow")) {
			$task =new PluginCallbackTask($this->owner,[$this,"announce"],[$pl->getName()]);
		} else {
			$task =new PluginCallbackTask($this->owner,[$this,"kickuser"],[$pl->getName()]);
		}
		$this->owner->getServer()->getScheduler()->scheduleDelayedTask($task,self::$delay);
	}
	public function announce($pn) {
		$player = $this->owner->getServer()->getPlayer($pn);
		if (!($player instanceof Player)) return;
		$player->sendMessage(TextFormat::RED.mc::_("NOTE: currently in service mode"));
		$player->sendMessage(TextFormat::YELLOW."- ".$this->mode);
	}
	public function kickuser($pn) {
		$player = $this->owner->getServer()->getPlayer($pn);
		if (!($player instanceof Player)) return;
		$this->owner->getServer()->broadcastMessage(TextFormat::RED.mc::_("%1% attempted to join",$pn));
		$player->kick($this->mode);
	}
}
<?php
//= cmd:opms,Server_Management
//: sends a message to ops only
//> usage: **opms** _[msg]_
//:
//: Sends chat messages that are only see by ops.  Only works with ops
//: that are on-line at the moment.  If you no ops are on-line you
//: should use the **rpt** command.

//= cmd:rpt,Server_Management
//: report an issue to ops
//> usage: **rpt** [_message_|**read|clear** _<all|##>_]
//:
//: Logs/reports an issue to server ops.  These issues are stored in a
//: a file which can be later read by the server operators.  Use this
//: when there are **no** ops on-line.  If there are ops on-line you
//: should use the **opms** command.
//:
//: The following ops only commands are available:
//> - **rpt** **read** _[##]_
//:   - reads reports.  You can specify the page by specifying a number.
//> - **rpt** **clear** _<all|##>_
//:   - will delete the specified report or if **all**, all the reports.

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerJoinEvent;

use pocketmine\Player;
use pocketmine\utils\TextFormat;
use pocketmine\utils\Config;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

class CmdOpMsg extends BasicCli implements CommandExecutor,Listener {
	protected $rpt;

	public function __construct($owner) {
		parent::__construct($owner);

		PermUtils::add($this->owner, "gb.cmd.opms", "Send op only messages", "true");
		PermUtils::add($this->owner, "gb.cmd.rpt", "Report issues", "true");
		PermUtils::add($this->owner, "gb.cmd.rpt.read", "Read reported issues", "op");

		$this->enableCmd("opms",
							  ["description" => mc::_("Send message to ops"),
								"usage" => mc::_("/opms <message>"),
								"permission" => "gb.cmd.opms"]);
		$this->enableCmd("rpt",
							  ["description" => mc::_("Report issues to ops"),
								"usage" => mc::_("/rpt [message|read|clear <all|##>]"),
								"permission" => "gb.cmd.rpt"]);
		$this->rpt = new Config($this->owner->getDataFolder()."reports.yml",
										Config::YAML,[0,[]]);
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
		list($id,$rpt) = $this->rpt->getAll();
		if (count($rpt))
			$this->owner->getLogger()->info(
				TextFormat::RED.
				mc::n(mc::_("One report on file"),
						mc::_("%1% reports on file",count($rpt)),
						count($rpt)));
	}
	public function rptCmd(CommandSender $sender,array $args) {
		if (count($args) == 0) return false;
		list($id,$rpt) = $this->rpt->getAll();
		if ($args[0] == "read" && (count($args) == 1 ||
											(count($args) == 2 && is_numeric($args[1])))) {
			if (!MPMU::access($sender,"gb.cmd.rpt.read")) return false;
			if (count($rpt) == 0) {
				$sender->sendMessage(TextFormat::RED.mc::_("No reports on file!"));
				return true;
			}
			$pageNumber = $this->getPageNumber($args);
			$tab = [[ mc::_("ID"),mc::_("Date"),mc::_("Name"),
						mc::_("Reports: %1%",count($rpt)) ]];
			foreach ($rpt as $i=>$ln) {
				list($tm,$name,$ms) = $ln;
				$tm = date(mc::_("d-M H:i"),$tm);
				$tab[] = [ $i,$tm,$name,$ms ];
			}
			$this->paginateTable($sender,$pageNumber,$tab);
			return true;
		}
		if ($args[0] == "clear" && count($args) == 2) {
			if (!MPMU::access($sender,"gb.cmd.rpt.read")) return false;
			if ($args[1] == "all") {
				$rpt = [];
				$sender->sendMessage(TextFormat::RED.mc::_("All reports deleted"));
			} else {
				$i = intval($args[1]);
				if (!isset($rpt[$i])) {
					$sender->sendMessage(mc::_("Unknown report #%1%",$i));
					return true;
				}
				unset($rpt[$i]);
				$sender->sendMessage(mc::_("Deleting report #%1%",$i));
			}
		} else {
			$rpt[++$id] = [time(),$sender->getName(),implode(" ",$args)];
			$sender->sendMessage(mc::_("Report filed as #%1%",$id));
			$ms = TextFormat::BLUE.
				mc::_("Rpt[#%1% from %2%] ",$id,$sender->getName()).
				TextFormat::YELLOW.implode(" ",$args);
			$this->owner->getLogger()->info($ms);
			foreach ($this->owner->getServer()->getOnlinePlayers() as $pl) {
				if (!$pl->isOp()) continue;
				$pl->sendMessage($ms);
			}
		}
		$this->rpt->setAll([$id,$rpt]);
		$this->rpt->save();
		return true;
	}
	public function opmsgCmd(CommandSender $sender, array $args) {
		if (count($args) == 0) return false;
		$ms = TextFormat::BLUE.mc::_("OpMsg [%1%] ",$sender->getName()).
			TextFormat::YELLOW.implode(" ",$args);
		$this->owner->getLogger()->info($ms);
		$count = 0;
		foreach ($this->owner->getServer()->getOnlinePlayers() as $pl) {
			if (!$pl->isOp()) continue;
			$pl->sendMessage($ms);
			++$count;
		}
		if (($sender instanceof Player) && !$sender->isOp()) {
			if($count){
				$sender->sendMessage(mc::_("(ops:%1%) ",$count).implode(" ",$args));
			}else{
				$sender->sendMessage(mc::_("Message sent to console only"));
				if ($sender->hasPermission("gb.cmd.rpt")) {
					$sender->sendMessage(mc::_("Try /rpt instead"));
				}
			}
		}
		return true;
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		switch($cmd->getName()) {
			case "opms":
			  return $this->opmsgCmd($sender,$args);
			case "rpt":
				return $this->rptCmd($sender,$args);
		}
		return false;
	}
	public function onPlayerJoin(PlayerJoinEvent $e) {
		$pl = $e->getPlayer();
		if ($pl == null) return;
		if (!$pl->hasPermission("gb.cmd.rpt.read")) return;
		list($id,$rpt) = $this->rpt->getAll();
		if (count($rpt)) $pl->sendMessage(
			mc::n(mc::_("One report on file"),
					mc::_("%1% reports on file",count($rpt)),
					count($rpt)));
	}
}
<?php
//= cmd:entities,Entity_Management
//: entity management
//> usage: **entities** _[subcommand]_ _[options]_
//:
//: By default it will show the current entities.  The following
//: sub-commands are available:
//> - **entities** **ls** _[world]_
//:    - Show entities in _[world]_ (or current world if not specified).
//> - **entities** **tiles** _[world]_
//:    - Show tile entities in _[world]_ (or current world if not specified).
//> - **entities** **info** _[e#|t#]_
//:    - Show details about one or more entities or tiles.
//: - **entities** **rm** _[e#]_
//:    - Removes one or more entities.
//: - **entities** **sign**_N_ _[t#]_ _message text_
//:    - Changes the text line _N_ in the tile/sign identified by _t#_.
//: - **entities** **count**
//:    - Show a count of the number of entities on the server.
//: - **entities** **nuke** _[all|mobs|others]_
//:    - Clear entities from the server.
//:
//: Additionally, tiles can be specified by providing the following:
//:
//: - t(x),(y),(z)[,world]

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\math\Vector3;

use pocketmine\Player;
use pocketmine\entity\Living;
use pocketmine\entity\Human;
use pocketmine\entity\Creature;
use pocketmine\tile\Sign;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\ItemName;
use aliuly\grabbag\common\PermUtils;

class CmdEntities extends BasicCli implements CommandExecutor {
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.entities", "entity management", "op");
		$this->enableCmd("entities",
							  ["description" => mc::_("Manage entities"),
								"usage" => mc::_("/entities [tile|info|rm|sign#|count|nuke] [args]"),
								"aliases" => ["et"],
								"permission" => "gb.cmd.entities"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "entities") return false;
		if (count($args) == 0) $args = [ "ls" ];
		$scmd = strtolower(array_shift($args));

		switch ($scmd) {
			case "count":
				return $this->cmdCount($sender);
			case "nuke":
				return $this->cmdNuke($sender,$args);
			case "ls":
				return $this->cmdEtList($sender,$args);
			case "tiles":
			case "tile":
				return $this->cmdTileList($sender,$args);
			case "info":
			case "nbt":
				return $this->cmdEtInfo($sender,$args);
			case "rm":
				return $this->cmdEtRm($sender,$args);
			case "sign1":
			case "sign2":
			case "sign3":
			case "sign4":
				return $this->cmdEtSign($sender,$scmd,$args);
		}
		return false;
	}
	//////////////////////////////////////////////////////////////////////
	//
	// Support functions
	//
	//////////////////////////////////////////////////////////////////////
	private function dumpNbtIndent($spc,&$off,&$last) {
		if (isset($off[$spc])) return $off[$spc];
		$last += 2;
		$off[$spc] = str_repeat(' ',$last);
		return $off[$spc];
	}
	public function dumpNbt($nbt) {
		$txt = [];
		$name = '';
		$off=[];
		$last = 0;

		foreach (explode("\n",print_r($nbt,true)) as $ln) {
			if (trim($ln) == "(" || trim($ln) == ")" || trim($ln) == "") continue;
			if (preg_match('/^(\s*)(\[[^\]]+\])\s*=>\s*pocketmine\\\\nbt\\\\tag\\\\(Enum|Compound)/',$ln,$m)) {
				$txt[] = ".".$this->dumpNbtIndent($m[1],$off,$last).$m[2];
				continue;
			}
			if (preg_match('/^\s*\[name:protected\]\s*=>\s*(.*)$/',$ln,$m)) {
				$name = $m[1];
			}
			if (preg_match('/^(\s*)\[value:protected\]\s*=>\s*(.*)$/',$ln,$m)) {
				if ($m[2] == "Array") continue;
				$txt[] = ".".$this->dumpNbtIndent($m[1],$off,$last).$name.": ".
						 $m[2];
				$name = "";
			}
		}
		return $txt;
	}
	private function getEntity($id) {
		if (strtolower(substr($id,0,1)) == "e") {
			$id = substr($id,1);
		}
		if (!is_numeric($id)) return null;
		$id = intval($id);
		foreach($this->owner->getServer()->getLevels() as $l) {
			$e = $l->getEntity($id);
			if ($e !== null) return $e;
		}
		return null;
	}
	private function getTile($id) {
		if (strtolower(substr($id,0,1)) == "t") {
			$id = substr($id,1);
		}
		if (preg_match('/^(\d+),(\d+),(\d+),(\S+)$/',$id,$mv)) {
			$l = $this->owner->getServer()->getLevelByName($mv[4]);
			if ($l === null) return null;
			$mv = new Vector3($mv[1],$mv[2],$mv[3]);
			return $l->getTile($mv);
		}
		if (preg_match('/^(\d+),(\d+),(\d+)$/',$id,$mv)) {
			$l = $this->owner->getServer()->getDefaultLevel();
			if ($l === null) return null;
			$mv = new Vector3($mv[1],$mv[2],$mv[3]);
			$e = $l->getTile($mv);
			if ($e !== null) return $e;
			foreach($this->owner->getServer()->getLevels() as $l) {
				$e = $l->getTile($mv);
				if ($e !== null) return $e;
			}
			return null;
		}
		if (!is_numeric($id)) return null;
		$id = intval($id);
		foreach($this->owner->getServer()->getLevels() as $l) {
			$e = $l->getTileById($id);
			if ($e !== null) return $e;
		}
		return null;
	}
	//////////////////////////////////////////////////////////////////////
	//
	// Sub commands
	//
	//////////////////////////////////////////////////////////////////////
	private function cmdEtList(CommandSender $c,$args) {
		$pageNumber = $this->getPageNumber($args);
		if (count($args) > 1) {
			$c->sendMessage(mc::_("Usage: /et ls [world]"));
			return false;
		}
		if (count($args)) {
			$level = $this->owner->getServer()->getLevelByName($args[0]);
			if (!$level) {
				$c->sendMessage(mc::_("%1%: World not found",$args[0]));
				return true;
			}
		} else {
			if (MPMU::inGame($c,false)) {
				$level = $c->getLevel();
			} else {
				$level = $this->owner->getServer()->getDefaultLevel();
			}
		}

		$cnt=0;
		$tab = [];
		$tab[] = ["-",mc::_("Name"),mc::_("Position"),mc::_("Health")];
		foreach ($level->getEntities() as $e) {
			if ($e instanceof Player) continue;
			$id = $e->getId();
			$pos = implode(",",[floor($e->getX()),floor($e->getY()),floor($e->getZ())]);
			if ($e instanceof Living) {
				$name = $e->getName();
			} elseif ($e instanceof \pocketmine\entity\Item) {
				$name = mc::_("Item:%1%",ItemName::str($e->getItem()));
			} else {
				$name = basename(strtr(get_class($e),"\\","/"));
			}
			++$cnt;
			$tab[] = [ $id,$name,$pos,$e->getHealth() ];
		}
		$tab[0][0] = "#:$cnt";
		if ($cnt) return $this->paginateTable($c,$pageNumber,$tab);
		$c->sendMessage(mc::_("No entities found"));
		return true;
	}
	private function cmdTileList(CommandSender $c,$args) {
		$pageNumber = $this->getPageNumber($args);
		if (count($args) > 1) {
			$c->sendMessage(mc::_("Usage: /et tiles [world]"));
			return false;
		}
		if (count($args)) {
			$level = $this->owner->getServer()->getLevelByName($args[0]);
			if (!$level) {
				$c->sendMessage(mc::_("%1%: World not found",$args[0]));
				return true;
			}
		} else {
			if (MPMU::inGame($c,false)) {
				$level = $c->getLevel();
			} else {
				$level = $this->owner->getServer()->getDefaultLevel();
			}
		}
		$cnt = 0;
		$tab = [];
		$tab[] = ["-",mc::_("Name"),mc::_("Position")];
		foreach ($level->getTiles() as $t) {
			$id = $t->getId();
			$pos = implode(",",[floor($t->getX()),floor($t->getY()),floor($t->getZ())]);
			$name = basename(strtr(get_class($t),"\\","/"));
			$tab[] = [ $id,$name,$pos ];
			++$cnt;
		}
		$tab[0][0] = "#:$cnt";
		if ($cnt) return $this->paginateTable($c,$pageNumber,$tab);
		$c->sendMessage(mc::_("No tiles found"));
		return true;
	}
	private function cmdNuke(CommandSender $c,$args) {
		$mobs = true;
		$ents = false;
		if (count($args) == 1) {
			switch(strtolower($args[0])) {
				case "others":
					$mobs = false;
					$ents = true;
					break;
				case "mobs":
					$mobs = true;
					$ents = false;
					break;
				case "all":
					$mobs = true;
					$ents = true;
					break;
				default:
					$c->sendMessage(mc::_("Invalid option"));
					return false;
			}
		} elseif (count($args) != 0) {
			$c->sendMessage(mc::_("NUKE Options: all, mobs, others"));
			return false;
		}
		$mcnt = $ecnt = 0;
		foreach($this->owner->getServer()->getLevels() as $l) {
			foreach($l->getEntities() as $e) {
				if($e instanceof Human) continue;
				if (($e instanceof Creature) && $mobs) {
					$mcnt++;
					$e->close();
					continue;
				}
				if ($ents) {
					$ecnt++;
					$e->close();
				}
			}
		}
		if ($mcnt) $c->sendMessage(mc::_("Removed %1% mobs",$mcnt));
		if ($ecnt) $c->sendMessage(mc::_("Removed %1% entities",$ecnt));
		if ($mcnt == 0 && $ecnt == 0) $c->sendMessage(mc::_("Nothing was deleted"));
		return true;
	}
	private function cmdCount(CommandSender $c) {
		$humans = 0;
		$mobs = 0;
		$others = 0;
		$tiles = 0;
		foreach ($this->owner->getServer()->getLevels() as $l) {
			foreach ($l->getEntities() as $e) {
				if ($e instanceof Human)
					++$humans;
				elseif($e instanceof Creature)
					++$mobs;
				else
					++$others;
			}
			$tiles += count($l->getTiles());
		}
		$c->sendMessage(mc::_("Players: %1%",$humans));
		$c->sendMessage(mc::_("Mobs:    %1%",$mobs));
		$c->sendMessage(mc::_("Others:  %1%",$others));
		$c->sendMessage(mc::_("Tiles:   %1%",$tiles));
		return true;
	}
	private function cmdEtInfo(CommandSender $c,$args) {
		$pageNumber = $this->getPageNumber($args);
		if (count($args) == 0) {
			$c->sendMessage(mc::_("Usage: /et info [ids]"));
			return false;
		}
		$cnt = 0;
		$txt = [];
		if (count($args) > 1) {
			$txt[] = "";
		}
		foreach ($args as $i) {
			$et = $this->getEntity($i);
			if ($et !== null) {
				$txt[] = mc::_("Entity: %1% (%2%)",$i,basename(strtr(get_class($et),"\\","/")));
				$et->saveNBT();
				foreach ($this->dumpNbt($et->namedtag) as $ln) {
					$txt[] = $ln;
				}
				continue;
			}
			$tile = $this->getTile($i);
			if ($tile !== null) {
				++$cnt;
				$txt[] = mc::_("Tile: %1%",$i);
				foreach ($this->dumpNbt($tile->namedtag) as $ln) {
					$txt[] = $ln;
				}
				continue;
			}
			$c->sendMessage(mc::_("Id:%1% not found",$i));
		}
		if (count($args) > 1) {
			$txt[0] = mc::_("%1% Entities",$cnt);
		}
		return $this->paginateText($c,$pageNumber,$txt);
	}
	private function cmdEtRm(CommandSender $c,$args) {
		if (count($args) == 0) {
			$c->sendMessage(mc::_("Usage: /et rm [ids]"));
			return false;
		}
		$lst = [];

		foreach ($args as $i) {
			$et = $this->getEntity($i);
			if ($et !== null) {
				$lst[] = $i;
				$et->close();
				continue;
			}
			$tile = $this->getTile($i);
			if ($tile !== null) {
				$lst[] = $i;
				$tile->close();
				continue;
			}
			$c->sendMessage(mc::_("Id:%1% not found",$i));
		}
		if (count($lst)) {
			$c->sendMessage(mc::_("Removed %1% items: %2%",count($lst),
										 implode(", ",$lst)));
		} else {
			$c->sendMessage(mc::_("No items removed"));
		}
		return true;
	}

	private function cmdEtSign(CommandSender $c,$opt,$args) {
		if (count($args) < 1) {
			$c->sendMessage(mc::_("Usage: /et sign[1-4] <id> <text>\n"));
			return false;
		}
		$i = array_shift($args);
		$tile = $this->getTile($i);
		if ($tile == null) {
			$c->sendMessage(mc::_("Tile %1% not found",$i));
			return true;
		}
		if (strtolower(substr($i,0,1)) != "t") {
			$c->sendMessage(mc::_("Only applies to tile ids"));
			return false;
		}
		if (!($tile instanceof Sign)) {
			$c->sendMessage(mc::_("Tile %1% is not a sign",$i));
			return false;
		}
		$sign = $tile->getText();
		$txt = implode(" ",$args);
		$sub = intval(substr($opt,-1)) - 1;
		if ($sign[$sub] == $txt) {
			$c->sendMessage(mc::_("Text unchanged"));
			return true;
		}
		$sign[$sub] = $txt;
		$tile->setText($sign[0],$sign[1],$sign[2],$sign[3]);
		$c->sendMessage(mc::_("Changed to \"%1%\"",$txt));
		return true;
	}

}
<?php
//= cmd:after,Server_Management
//: schedule command after a number of seconds
//> usage: **after** _<seconds>_ _<command>|list|cancel_ _<id>_
//:
//: Will schedule to run *command* after *seconds*.
//: The **list** sub command will show all the queued commands.
//: The **cancel** sub command allows you to cancel queued commands.
//:
//= cmd:at,Server_Management
//: schedule command at an appointed date/time
//> usage: **at** _<time>_ _[:]_ _<command>|list|cancel _<id>_
//:
//: Will schedule to run *command* at the given date/time.  This uses
//: php's [strtotime](http://php.net/manual/en/function.strtotime.php)
//: function so _times_ must follow the format described in
//: [Date and Time Formats](http://php.net/manual/en/datetime.formats.php).
//: The **list** sub command will show all the queued commands.
//: The **cancel** sub command allows you to cancel queued commands.
//:
//= cmdnotes
//:
//: Commands scheduled by **at** and **after** will only run as
//: long as the server is running.  These scheduled commands will *not*
//: survive server reloads or reboots.  If you want persistent commands,
//: it is recommended that you use a plugin like
//: [TimeCommander](http://forums.pocketmine.net/plugins/timecommander.768/).
//:


namespace aliuly\grabbag;

use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PluginCallbackTask;
use aliuly\grabbag\common\PermUtils;

class CmdAfterAt extends BasicCli implements CommandExecutor {
	protected $tasks;
	public function __construct($owner) {
		parent::__construct($owner);
		$this->tasks = [];

		PermUtils::add($this->owner, "gb.cmd.after", "access command scheduler", "op");

		$this->enableCmd("after",
							  ["description" => mc::_("schedule to run a command after x seconds"),
								"usage" => mc::_("/after <seconds> <command>|list|cancel <id>"),
								"permission" => "gb.cmd.after"]);
		$this->enableCmd("at",
							  ["description" => mc::_("schedule to run a command at a certain time"),
								"usage" => mc::_("/at <time> <command>|list|cancel <id>"),
								"permission" => "gb.cmd.after"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		// Collect expired tasks out of the tasks table...
		foreach (array_keys($this->tasks) as $tid) {
			if (!$this->owner->getServer()->getScheduler()->isQueued($tid)) {
				unset($this->tasks[$tid]);
			}
		}
		switch($cmd->getName()) {
			case "after":
			  if ($this->commonSubs($sender,$args)) return true;
				return $this->cmdAfter($sender,$args);
			case "at":
				if ($this->commonSubs($sender,$args)) return true;
				return $this->cmdAt($sender,$args);
		}
		return false;
	}
	public function runCommand($cmd) {
		$this->owner->getServer()->dispatchCommand(new ConsoleCommandSender(),$cmd);
	}
	private function commonSubs(CommandSender $c,$args){
		if (count($args) == 0) return false;
		switch (strtolower($args[0])){
			case "list":
			case "ls":
				if (count($this->tasks) == 0) {
					$c->sendMessage(mc::_("No tasks currently scheduled"));
					return true;
				}
				$pageNumber = $this->getPageNumber($args);
				$tab = [ [	mc::_("Id"), mc::_("When"),
										mc::n(mc::_("One scheduled task"),
											 mc::_("%1% scheduled tasks",count($this->tasks)),
											count($this->tasks)) ] ];
				foreach ($this->tasks as $tid => $cmd) {
					list($when,$line) = $cmd;
					$tab[] = [ $tid, date(mc::_("d-M-Y H:i:s"),$when), $line ];
				}
				return $this->paginateTable($c,$pageNumber,$tab);
			case "cancel":
				if (count($args) != 2) return false;
				if (!isset($this->tasks[$args[1]])){
					$c->sendMessage(mc::_("Task %1% not found!",$args[1]));
					return true;
				}
				$this->owner->getServer()->getScheduler()->cancelTask($args[1]);
				$c->sendMessage(mc::_("Cancelling Task %1%",$args[1]));
				return true;
		}
		return false;
	}
  public function schedule($secs,$cmdline) {
		$h = $this->owner->getServer()->getScheduler()->scheduleDelayedTask(
			new PluginCallbackTask($this->owner,[$this,"runCommand"],[$cmdline]),
			$secs * 20
		);
		$this->tasks[$h->getTaskId()] = [time()+$secs,$cmdline];
	}
	private function cmdAfter(CommandSender $c,$args) {
		if (count($args) < 2) return false;
		if (!is_numeric($args[0])) {
			$c->sendMessage(mc::_("Unable to specify delay %1%",$args[0]));
			return false;
		}
		$secs = array_shift($args);
		$c->sendMessage(mc::_("Scheduled for %1%",date(DATE_RFC2822,time()+$secs)));
		$h = $this->owner->getServer()->getScheduler()->scheduleDelayedTask(
			new PluginCallbackTask($this->owner,[$this,"runCommand"],[implode(" ",$args)]),
			$secs * 20
		);
		$this->tasks[$h->getTaskId()] = [time()+$secs,implode(" ",$args)];
		return true;
	}
	private function cmdAt(CommandSender $c,$args) {
		if (count($args) < 2) {
			$c->sendMessage(mc::_("Time now is: %1%",date(DATE_RFC2822)));
			return false;
		}
		if (($pos = array_search(":",$args)) != false) {
			if ($pos == 0) return false;
			$ts = [];
			while ($pos--) {
				$ts[] = array_shift($args);
			}
			array_shift($args);
			if (count($args) == 0) return false;
			$ts = implode(" ",$ts);
			$when = strtotime($ts);
		} else {
			for ($ts = array_shift($args);
				  ($when = strtotime($ts)) == false && count($args) > 1;
				  $ts .= ' '.array_shift($args)) ;
		}
		if ($when == false) {
			$c->sendMessage(mc::_("Unable to parse time specification %1%",$ts));
			return false;
		}
		while ($when < time()) {
			$when += 86400; // We can not travel back in time...
		}
		$c->sendMessage(mc::_("Scheduled for %1%",date(DATE_RFC2822,$when)));
		$h = $this->owner->getServer()->getScheduler()->scheduleDelayedTask(
			new PluginCallbackTask($this->owner,[$this,"runCommand"],[implode(" ",$args)]),
			($when - time())*20
		);
		$this->tasks[$h->getTaskId()] = [$when, implode(" ",$args)];
		return true;
	}
}
<?php
//= cmd:summon,Teleporting
//: Summons a player to your location
//> usage: **summon** _<player>_ _[message]_

//= cmd:dismiss,Teleporting
//: Dismiss a previously summoned player
//> usage: **dismiss** _<player>_ _[message]_
namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\level\Position;
use pocketmine\math\Vector3;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

class CmdSummon extends BasicCli implements CommandExecutor {

	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.summon", "summon|dismmiss command", "op");
		$this->enableCmd("summon",
							  ["description" => mc::_("Teleports players to your location"),
								"usage" => mc::_("/summon <player> [message]"),
								"permission" => "gb.cmd.summon"]);
		$this->enableCmd("dismiss",
							  ["description" => mc::_("Dismisses summoned players"),
								"usage" => mc::_("/dismiss <player|--all>"),
								"permission" => "gb.cmd.summon"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		switch($cmd->getName()) {
			case "summon":
				return $this->cmdSummon($sender,$args);
			case "dismiss":
				return $this->cmdDismiss($sender,$args);
		}
		return false;
	}

	public function cmdSummon(CommandSender $c,$args) {
		if (count($args) == 0) return false;
		if (!MPMU::inGame($c)) return true;
		$pl = $this->owner->getServer()->getPlayer($args[0]);
		if (!$pl) {
			$c->sendMessage(mc::_("%1% can not be found.",$args[0]));
			return true;
		}
		array_shift($args);
		if (count($args)) {
			$pl->sendMessage(implode(" ",$args));
		} else {
			$pl->sendMessage(mc::_("You have been summoned by %1%",$c->getName()));
		}

		// Do we need to save current location?
		$state = $this->getState($c,[]);
		$pn = strtolower($pl->getName());
		if (!isset($state[$pn])) {
			$state[$pn] = new Position($pl->getX(),$pl->getY(),$pl->getZ(),
												$pl->getLevel());
		}
		$this->setState($c,$state);
		$mv = new Vector3($c->getX()+mt_rand(-3,3),$c->getY(),
								$c->getZ()+mt_rand(-3,3));
		$c->sendMessage(mc::_("Summoning %1%....",$pn));

		$pl->teleport($c->getLevel()->getSafeSpawn($mv));
		return true;
	}
	public function cmdDismiss(CommandSender $c,$args) {
		if (count($args) == 0) return false;
		if (!MPMU::inGame($c)) return true;

		$state = $this->getState($c,[]);
		if (count($state) == 0) {
			$c->sendMessage(mc::_("There is nobody to dismiss"));
			$c->sendMessage(mc::_("You need to summon people first"));
			return true;
		}

		if ($args[0] == "--all") $args = array_keys($state);

		foreach ($args as $i) {
			$pl = $this->owner->getServer()->getPlayer($i);
			if (!$pl) {
				$c->sendMessage(mc::_("%1% can not be found.",$i));
				$i = strtolower($i);
				if (isset($state[$i])) unset($state[$i]);
				continue;
			}
			$pn = strtolower($pl->getName());
			if (!isset($state[$pn])) {
				$c->sendMessage(mc::_("%1% was never summoned",$i));
				continue;
			}
			$pl->sendMessage(mc::_("You have been dismissed by %1%",$c->getName()));
			$c->sendMessage(mc::_("Dismissing %1%",$i));
			$pl->teleport($state[$pn]);
			unset($state[$pn]);
		}
		$this->setState($c,$state);
		return true;
	}
}
<?php
//= cmd:pushtp,Teleporting
//: Saves current location and teleport
//> usage: **pushtp** _<player>_ _[target]_

//= cmd:poptp,Teleporting
//: Returns to the previous location
//> usage: **poptp**
namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\level\Position;
use pocketmine\math\Vector3;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

class CmdTpStack extends BasicCli implements CommandExecutor {

	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.pushpoptp", "position stack", "op");
		$this->enableCmd("pushtp",
							  ["description" => mc::_("Save your current position when teleporting"),
								"usage" => mc::_("/pushtp [player|position|world]"),
								"permission" => "gb.cmd.pushpoptp"]);
		$this->enableCmd("poptp",
							  ["description" => mc::_("Returns to previously saved coordinates"),
								"usage" => mc::_("/poptp"),
								"permission" => "gb.cmd.pushpoptp"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		switch($cmd->getName()) {
			case "pushtp":
				return $this->cmdPushTp($sender,$args);
			case "poptp":
				return $this->cmdPopTp($sender,$args);
		}
		return false;
	}

	public function cmdPushTp(CommandSender $c,$args) {
		if (!MPMU::inGame($c)) return true;

		// Determine target...
		if (count($args) == 3 && is_numeric($args[0]) && is_numeric($args[1]) && is_numeric($args[2])) {
			$target = new Vector3($args[0],$args[1],$args[2]);
		} elseif (count($args) == 1 || count($args) == 4) {
			// is it a person or a world?...
			if (count($args) == 1
				 && ($pl = $this->owner->getServer()->getPlayer($args[0]))) {
				$target = $pl;
			} else {
				// Assume it is a level...
				$level = array_shift($args);
				if (count($args) == 3) {
					if (!(is_numeric($args[0]) && is_numeric($args[1]) && is_numeric($args[2]))) {
						$c->sendMessage(mc::_("Invalid coordinate set"));
						return true;
					}
					$cc = new Vector3($args[0],$args[1],$args[2]);
				} else {
					$cc = null;
				}
				if (!$this->owner->getServer()->isLevelLoaded($level)) {
					if (!$this->owner->getServer()->loadLevel($level)) {
						$c->sendMessage(mc::_("Level not found %1%",$level));
						return true;
					}
				}
				$level = $this->owner->getServer()->getLevelByName($level);
				if (!$level) {
					$c->sendMesage(mc::_("%1% not found.",$level));
					return treu;
				}
				$target = $level->getSafeSpawn($cc);
			}
		} elseif (count($args) == 0) {
			$target = null;
		} else {
			return false;
		}

		// save location...
		$stack = $this->getState($c,[]);
		array_push($stack,new Position($c->getX(),$c->getY(),$c->getZ(),
												 $c->getLevel()));
		$this->setState($c,$stack);

		$c->sendMessage(mc::_("Position saved!"));
		if ($target) {
			$c->sendMessage(mc::_("Teleporting..."));
			$c->teleport($target);
		}
		return true;
	}
	public function cmdPopTp(CommandSender $c,$args) {
		if (!MPMU::inGame($c)) return true;
		if (count($args)) return false;

		$stack = $this->getState($c,[]);
		if (count($stack) == 0) {
			$c->sendMessage(mc::_("TpStack is empty"));
			return true;
		}
		$pos = array_pop($stack);
		$c->sendMessage(mc::_("Teleporting..."));
		$c->teleport($pos);
		$this->setState($c,$stack);
		return true;
	}
}
<?php
//= cmd:prefix,Player_Management
//: prepend prefix to chat lines
//> usage: **prefix** _[-n]_ _<prefix text>_
//:
//: This allows you to prepend a prefix to chat lines.
//: To stop enter **/prefix** by itself (or **prefix** at the console).
//: Usage examples:
//:
//: - Send multiple **/as player** commands in a row.
//: - Start a private chat **/tell player** with another player.
//: - You prefer commands over chat: **/prefix -n /**
//:
//: When prefix is enabled and you one to send just _one_ command without
//: prefix, prepend your text with **<**.

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\event\Listener;
use pocketmine\Player;

use pocketmine\event\player\PlayerCommandPreprocessEvent;
use pocketmine\event\server\RemoteServerCommandEvent;
use pocketmine\event\server\ServerCommandEvent;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PermUtils;

class CmdPrefixMgr extends BasicCli implements CommandExecutor,Listener {
	static $delay = 5;
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.prefix", "Prefix command", "true");

		$this->enableCmd("prefix",
							  ["description" => mc::_("Execute commands with prefix inserted"),
								"usage" => mc::_("/prefix [-n] <text>"),
								"permission" => "gb.cmd.prefix"]);
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "prefix") return false;
		if (count($args) == 0 || (count($args) == 1 && $args[0] == "-n")) {
			$this->unsetState($sender);
			$sender->sendMessage(mc::_("prefix turned off"));
			return true;
		}
		$sep = " ";
		if ($args[0] == "-n") {
			$sep = "";
			array_shift($args);
		}
		$this->setState($sender,$n = implode(" ",$args).$sep);
		$sender->sendMessage(mc::_("Prefix set to \"%1%\"",$n));
		return true;
	}
	private function processCmd($msg,$sender) {
		$prefix = $this->getState($sender,"");
		if ($prefix == "") return false;
		if ($msg{0} == "<") return false; // Just this command we do it without prefix!
		if ($sender instanceof Player) {
			if (preg_match('/^\s*\/prefix\s*/',$msg)) return false;
		} else {
			if (preg_match('/^\s*prefix\s*/',$msg)) return false;
		}
		if (!($sender instanceof Player)) $sender->sendMessage(">> $prefix$msg");
		return $prefix.$msg;
	}
	/**
	 * @priority LOW
	 */
	public function onPlayerCmd(PlayerCommandPreprocessEvent $ev) {
		if ($ev->isCancelled()) return;
		$res = $this->processCmd($ev->getMessage(),$ev->getPlayer());
		if ($res === false) return;
		$ev->setMessage($res);
	}
	/**
	 * @priority LOW
	 */
	public function onRconCmd(RemoteServerCommandEvent $ev) {
		$res = $this->processCmd($ev->getCommand(),$ev->getSender());
		if ($res === false) return;
		$ev->setCommand($res);
	}
	/**
	 * @priority LOW
	 */
	public function onConsoleCmd(ServerCommandEvent $ev) {
		$res = $this->processCmd($ev->getCommand(),$ev->getSender());
		if ($res === false) return;
		$ev->setCommand($res);
	}
}
<?php
//= cmd:spawn,Teleporting
//: Teleport player to spawn point
//> usage: **spawn**
namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

class CmdSpawn extends BasicCli implements CommandExecutor {
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.spawn", "Teleport to spawn", "true");
		$this->enableCmd("spawn",
							  ["description" => mc::_("Teleport to spawn location"),
								"usage" => mc::_("/spawn"),
								"permission" => "gb.cmd.spawn"]);
	}
	public function tpSpawn($pl) {
		$pos = $pl->getLevel()->getSafeSpawn();
		$pl->teleport($pos);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "spawn") return false;
		if (count($args) != 0) return false;
		if (!MPMU::inGame($sender)) return true;
		$sender->sendMessage("Teleporting to spawn...");
		$this->tpSpawn($sender);
		return true;
	}
}
<?php
//= cmd:burn,Trolling
//: Burns the specified player
//> usage: **burn** _<player>_ _[secs]_
//:
//: Sets _player_ on fire for the specified number of seconds.
//: Default is 15 seconds.
//:
namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PermUtils;


class CmdBurn extends BasicCli implements CommandExecutor {
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.burn", "Burn other players", "op");
		$this->enableCmd("burn",
							  ["description" => mc::_("Set player on fire"),
								"usage" => mc::_("/burn <player> [secs]"),
								"permission" => "gb.cmd.burn"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "burn") return false;
		if (count($args) > 2 || count($args) == 0) return false;
		$pl = $this->owner->getServer()->getPlayer($args[0]);
		if (!$pl) {
			$sender->sendMessage(mc::_("%1% not found",$args[0]));
			return true;
		}
		$secs = 15;
		if (isset($args[1])) $secs = intval($args[1]);
		if ($secs <= 1) $secs = 15;
		$pl->setOnFire($secs);
		return true;
	}
}
<?php
//= cmd:blowup,Trolling
//: explode a player
//> usage: **blowup** _<player>_ _[yield]_ **[magic]** **[normal]**
//:
//: Explodes _player_ with an explosion with the given _yield_ (a number).
//: If **magic** is specified no damage will be taken by blocks.  The
//: default is **normal**, where blocks do get damaged.

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PermUtils;

use pocketmine\event\entity\ExplosionPrimeEvent;
use pocketmine\level\Explosion;


class CmdBlowUp extends BasicCli implements CommandExecutor {
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.blowup", "Explode other players", "op");
		$this->enableCmd("blowup",
							  ["description" => mc::_("Explode a player"),
								"usage" => mc::_("/blowup <player> [yield|magic|normal]"),
								"permission" => "gb.cmd.blowup"]);
	}
	public function blowPlayer($pl,$yield,$magic) {
		$this->owner->getServer()->getPluginManager()->callEvent($cc = new ExplosionPrimeEvent($pl,$yield));
		if ($cc->isCancelled()) return false;
		$explosion = new Explosion($pl,$yield);
		if (!$magic) $explosion->explodeA();
		$explosion->explodeB();
		return true;
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "blowup") return false;
		if (count($args) == 0) return false;
		$pl = $this->owner->getServer()->getPlayer($args[0]);
		if (!$pl) {
			$sender->sendMessage(mc::_("%1% not found.",$args[0]));
			return true;
		}
		array_shift($args);
		$yield = 5;
		$magic = false;
		foreach ($args as $i) {
			if (is_numeric($i)) {
				$yield = intval($i);
				if ($yield < 1) $yield = 1;
			} elseif (strtolower($i) == "magic") {
				$magic = true;
			} elseif (strtolower($i) == "normal") {
				$magic = false;
			}
		}
		$this->blowPlayer($pl,$yield,$magic);
		return true;
	}
}
<?php
//= cmd:setarmor,Inventory_Management
//: Sets armor (even in creative)
//> usage: **setarmor** _[player]_ _[part]_ _<quality>_
//:
//: This command lets you armor up.  It can armor up creative players too.
//: If no **player** is given, the player giving the command will be armored.
//:
//: Part can be one of **head**, **body**, **legs**, or **boots**.
//:
//: Quality can be one of **none**, **leather**, **chainmail**, **iron**,
//: **gold** or **diamond**.
namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\utils\TextFormat;
use pocketmine\item\Item;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\ArmorItems;
use aliuly\grabbag\common\PermUtils;

class CmdSetArmor extends BasicCli implements CommandExecutor {
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.setarmor", "Configure armor", "op");
		PermUtils::add($this->owner, "gb.cmd.setarmor.others", "Configure other's armor", "op");

		$this->enableCmd("setarmor",
							  ["description" => mc::_("Set armor (even in creative)"),
								"usage" => mc::_("/setarmor [player] [piece] <quality>"),
								"permission" => "gb.cmd.setarmor"]);
	}

	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if (count($args) == 0) return false;
		$i = array_pop($args);
		if (($type = ArmorItems::str2quality($i)) == ArmorItems::ERROR) {
			$sender->sendMessage(mc::_("Unknown armor quality %1%",$i));
			return false;
		}
		$slots = [0,1,2,3]; // All slots
		if (count($args)) {
			$i = ArmorItems::str2part($args[count($args)-1]);
			if ($i != ArmorItems::ERROR) {
				$slots = [ $i ];
				array_pop($args);
			}
		}
		$pl = $sender;
		if (count($args)) {
			$i = $this->owner->getServer()->getPlayer($args[count($args)-1]);
			if ($i) {
				$pl = $i;
				if (!MPMU::access($sender,"gb.cmd.setarmor.others")) return true;
				array_pop($args);
			}
		}
		if (count($args)) return false;
		if (!MPMU::inGame($pl)) return true;
		foreach($slots as $i) {
			$pl->getInventory()->setArmorItem($i,new Item(ArmorItems::getItemId($type,$i),0,1));
		}
		if ($type == ArmorItems::NONE)
			$sender->sendMessage(mc::_("Amouring down %1%",$pl->getName()));
		else
			$sender->sendMessage(mc::_("Amouring up %1%",$pl->getName()));
		// Make sure inventory is updated...
		$pl->getInventory()->sendArmorContents($pl);
		return true;
	}
}
<?php
//= cmd:followers,Teleporting
//: List who is following who
//> usage: **followers**

//= cmd:follow,Teleporting
//: Follow a player
//> usage: **follow** _<player>_

//= cmd:follow-off,Teleporting
//: stop following a player
//> usage: **follow-off**

//= cmd:followme,Teleporting
//: Make a player follow you
//> usage: **folowme** _<player>_

//= cmd:followme-off,Teleporting
//: stop making a player follow you
//> usage: **followme-off** _<player>_

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\event\Listener;
use pocketmine\Player;
use pocketmine\math\Vector3;
use pocketmine\event\player\PlayerMoveEvent;
use pocketmine\event\player\PlayerQuitEvent;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

class CmdFollowMgr extends BasicCli implements Listener,CommandExecutor {
	protected $leaders;
	protected $followers;
	protected $maxdist = 8;

	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.follow", "lets you follow others", "op");
		PermUtils::add($this->owner, "gb.cmd.followme", "let others follow you", "op");
		$this->enableCmd("followers",
							  ["description" => mc::_("List leads and followers"),
								"usage" => mc::_("/followers"),
								"permission" => "gb.cmd.follow;gb.cmd.followme"]);
		$this->enableCmd("follow",
							  ["description" => mc::_("pursue a player"),
								"usage" => mc::_("/follow [player]"),
								"permission" => "gb.cmd.follow"]);
		$this->enableCmd("follow-off",
							  ["description" => mc::_("stop following a player"),
								"usage" => mc::_("/follow-off"),
								"permission" => "gb.cmd.follow"]);
		$this->enableCmd("followme",
							  ["description" => mc::_("drag player with you"),
								"usage" => mc::_("/followme [player]"),
								"permission" => "gb.cmd.followme"]);
		$this->enableCmd("followme-off",
							  ["description" => mc::_("stop dragging a player"),
								"usage" => mc::_("/followme-off [player]"),
								"permission" => "gb.cmd.followme"]);
		$this->leaders = [];
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		$s = MPMU::iName($sender);
		switch ($cmd->getName()) {
			case "followers":
				$pageNumber = $this->getPageNumber($args);
				$txt = [ mc::_("Leads: %1%",count($this->leaders)) ];
				foreach ($this->leaders as $lead=>$followers) {
					$txt[]=$lead."(".count($followers)."):".implode(", ",$followers);
				}
				return $this->paginateText($sender,$pageNumber,$txt);
			case "follow":
				if (!MPMU::inGame($sender)) return true;
				if (count($args) != 1) return false;
				$n = array_shift($args);
				$player = $this->owner->getServer()->getPlayer($n);
				if (!$player) {
					$sender->sendMessage(mc::_("%1% not found.",$n));
					return true;
				}
				if (isset($this->followers[$s])) {
					$sender->sendMessage(mc::_("You are no longer following %1%",
														$this->followers[$s]));
					$this->stopFollowing($s);
				}
				$sender->sendMessage(mc::_("You are now following %1%",$n));
				$this->follow($s,$player);
				return true;
			case "follow-off":
				if (!MPMU::inGame($sender)) return true;
				if (count($args) != 0) return false;
				if (isset($this->followers[$s])) {
					$sender->sendMessage(mc::_("You are no longer following %1%",
														$this->followers[$s]));
					$this->stopFollowing($s);
				} else {
					$sender->sendMessage(mc::_("You are not following anybody"));
				}
				return true;
			case "followme":
				if (!MPMU::inGame($sender)) return true;
				if (count($args) == 0) return false;
				foreach ($args as $n) {
					$player = $this->owner->getServer()->getPlayer($n);
					if (!$player) {
						$sender->sendMessage(mc::_("%1% not found.",$n));
						continue;
					}
					$this->stopFollowing($player);
					$this->follow($player,$s);
					$sender->sendMessage(mc::_("%1% is now following you",$n));
					$player->sendMessage(mc::_("You are now following %1%",$s));
				}
				return true;
			case "followme-off":
				if (!MPMU::inGame($sender)) return true;
				if (count($args) != 0) return false;
				$this->stopLeading($s);
				$sender->sendMessage(mc::_("Nobody is following you"));
				return true;
		}
		return false;
	}
	private function approach($f,$l) {
		if (!($f instanceof Player)) {
			$f = $this->owner->getServer()->getPlayer($f);
			if (!$f) return; // Couldn't find this guy!
		}
		if (!($l instanceof Player)) {
			$l = $this->owner->getServer()->getPlayer($l);
			if (!$l) return; // Couldn't find this guy!
		}
		if (!$l->isonGround()) return; // We don't approach if leader is flying...

		if ($f->getLevel() === $l->getLevel()) {
			$dist = $f->distance($l);
			if ($dist < $this->maxdist) return; // Close enough
		}
		$pos = $l->getLevel()->getSafeSpawn(new Vector3($l->getX()+mt_rand(-$this->maxdist,$this->maxdist),
								 $l->getY(),
								 $l->getZ()+mt_rand(-$this->maxdist,$this->maxdist)));
		$newdist = $pos->distance($l);
		if ($newdist > $this->maxdist) return;// Will not get close enough!
		$f->teleport($pos);
	}
	//
	// Event handlers
	//
	public function onPlayerQuit(PlayerQuitEvent $ev) {
		$this->stopFollowing($ev->getPlayer());
		$this->stopLeading($ev->getPlayer());
	}
	public function onPlayerMoveEvent(PlayerMoveEvent $ev) {
		$n = MPMU::iName($ev->getPlayer());
		if (isset($this->followers[$n]))
			$this->approach($n,$this->followers[$n]);
		if (isset($this->leaders[$n])) {
			foreach ($this->leaders[$n] as $follower) {
				$this->approach($follower,$n);
			}
		}
	}
	// API related stuff...
	public function getLeaders() {
		return array_keys($this->leaders);
	}
	public function getFollowers($leader) {
		$leader = MPMU::iName($leader);
		return $this->leaders[$leader];
	}
	public function follow($follower,$leader) {
		$follower = MPMU::iName($follower);
		$leader = MPMU::iName($leader);
		if (isset($this->followers[$follower])) $this->followStop($follower);
		if (!isset($this->leaders[$leader])) {
			// First follower!
			$this->leaders[$leader] = [];
		}
		$this->leaders[$leader][$follower] = $follower;
		$this->followers[$follower] = $leader;
		$this->approach($follower,$leader);
	}
	public function stopFollowing($follower) {
		$follower = MPMU::iName($follower);
		if (!isset($this->followers[$follower])) return;
		$leader = $this->followers[$follower];
		unset($this->followers[$follower]);
		if (!isset($this->leaders[$leader])) return;
		if (isset($this->leaders[$leader][$follower]))
			unset($this->leaders[$leader][$follower]);
		if (count($this->leaders[$leader]) == 0)
			unset($this->leaders[$leader]);
	}
	public function stopLeading($leader) {
		$leader = MPMU::iName($leader);
		if (!isset($this->leaders[$leader])) return;
		foreach ($this->leaders[$leader] as $follower) {
			if (isset($this->followers[$follower]))
				unset($this->followers[$follower]);
		}
		unset($this->leaders[$leader]);
	}

	//
}
<?php
//= cmd:servers,Server_Management
//: Manage peer server connections
//> usage: **servers** **<add|rm|ls>** _[options]_
//:
//: This is used to manage the peer server definitions used by the
//: **RCON** and **QUERY** modules.
//:
//: Options:
//> - **servers add** _<id> <host> [port] [--rcon-port=port] [--rconpw=secret] [# comments]_
//:   - adds a new connection with **id**
//> - **servers rm** _<id>_
//:   - Removes peer **id**.
//> - **servers ls**
//:   - List configured peers.

//= cfg:ServerList
//: This section configures peer servers.  This can be used with
//: *rcon* and *query* commands.

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

use aliuly\grabbag\api\GbAddServerEvent;
use aliuly\grabbag\api\GbRemoveServerEvent;


class ServerList extends BasicCli implements CommandExecutor {
  const CfgTag = "serverlist";
  protected $servers;

  public function __construct($owner,$cfg) {
    parent::__construct($owner);
    $this->servers = $cfg;

    PermUtils::add($this->owner, "gb.cmd.servers", "servers command", "op");
    PermUtils::add($this->owner, "gb.cmd.servers.read", "view server configuration", "op");
    PermUtils::add($this->owner, "gb.cmd.servers.read.viewip", "view server IP address", "op");
    PermUtils::add($this->owner, "gb.cmd.servers.read.viewrcon", "view rcon secrets", "op");
    PermUtils::add($this->owner, "gb.cmd.servers.write", "change server configuration", "op");

    $this->enableCmd("servers",
                ["description" => mc::_("Manage server lists"),
                "usage" => mc::_("/servers <add|rm|ls> [opts]"),
                "aliases" => ["srv"],
                "permission" => "gb.cmd.servers"]);
  }

  public function getIds() {
    return array_keys($this->servers);
  }
  public function addServer($key,$val) {
    $this->owner->getServer()->getPluginManager()->callEvent(
	     $ev = new GbAddServerEvent($this->owner, $key, $val)
    );
    if ($ev->isCancelled()) return false;
    $this->servers[$ev->getId()] = $ev->getAttrs();
    $this->owner->cfgSave(self::CfgTag,$this->servers);
    return true;
  }
  public function rmServer($id) {
    if (!isset($this->servers[$id])) return true;
    $this->owner->getServer()->getPluginManager()->callEvent(
	     $ev = new GbAddServerEvent($this->owner, $key, $val)
     );
    if ($ev->isCancelled()) return false;
    $id = $ev->getId();
    if (!isset($this->servers[$id])) return true;
    unset($this->servers[$id]);
    $this->owner->cfgSave(self::CfgTag,$this->servers);
    return true;
  }
  public function getServer($id) {
    if (isset($this->servers[$id])) return $this->servers[$id];
    return null;
  }

  public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
    if (count($args) == 0) return false;
    switch($cmd->getName()) {
      case "servers":
        switch (strtolower($args[0])) {
          case "add":
            if (!MPMU::access($sender,"gb.cmd.servers.write")) return true;
            array_shift($args);
            return $this->cmdAdd($sender,$args);
          case "rm":
            if (!MPMU::access($sender,"gb.cmd.servers.write")) return true;
            array_shift($args);
            return $this->cmdRm($sender,$args);
          case "ls":
            if (!MPMU::access($sender,"gb.cmd.servers.read")) return true;
            array_shift($args);
            return $this->cmdList($sender,$args);
        }
    }
    return false;
  }
  private function cmdAdd(CommandSender $c,$args) {
    if (count($args) < 2) {
      $c->sendMessage(mc::_("Usage: add <id> <host> [port] [--rcon-port=port] [--rconpw=secret] [# comments]"));
      return false;
    }
    $id = array_shift($args);
    if (substr($id,0,1) == "-") {
      $c->sendMessage(mc::_("Server id can not start with a dash (-)"));
      return false;
    }
    if (strpos($id,",") !== false) {
      $c->sendMessage(mc::_("Server id can not contain commas (,)"));
      return false;
    }
    if (isset($this->servers[$id])) {
      $c->sendMessage(mc::_("%1% is an id that is already in use.",$id));
      $c->sendMessage(mc::_("Use rm first"));
      return false;
    }
    $dat = [
      "host" => array_shift($args),
      "port" => 19132,
    ];
    while (count($args)) {
      if (is_numeric($args[0])) {
        $dat["port"] = array_shift($args);
      } elseif (($i = MPMU::startsWith($args[0],"--rcon-port=")) !== null) {
        $dat["rcon-port"] = $i;
        array_shift($args);
      } elseif (($i = MPMU::startsWith($args[0],"--rconpw=")) !== null) {
        $dat["rcon-pw"] = $i;
        array_shift($args);
      } elseif (substr($args[0],0,1) == "#") {
        $dat["#"] = substr(implode(" ",$args),1);
        break;
      } else {
        $c->sendMessage(mc::_("Unknown option %1%",$args[0]));
        return false;
      }
    }
    if ($this->addServer($id,$dat))
      $c->sendMessage(mc::_("Server id %1% configured",$id));
    else
      $c->sendMessage(mc::_("Failed to configure %1%",$id));
    return true;
  }
  private function cmdRm(CommandSender $c,$args) {
    if (count($args) != 1) {
      $c->sendMessage(mc::_("Usage: rm <id>"));
      return false;
    }
    $id = array_shift($args);
    if (!isset($this->servers[$id])) {
      $c->sendMessage(mc::_("%1% does not exist",$id));
      return false;
    }
    if ($this->rmServer($id))
      $c->sendMessage(mc::_("Server id %1% deleted",$id));
    else
      $c->sendMessage(mc::_("Unable to delete id %1%",$id));
    return true;
  }
  private function cmdList(CommandSender $c,$args) {
    $pageNumber = $this->getPageNumber($args);
    $txt = ["Server connections"];
    foreach ($this->servers as $id => $dat) {
      $ln = $id;
      $q = ": ";
      if (MPMU::access($c,"gb.cmd.servers.read.viewip",false)) {
        $ln .= $q.$dat["host"].":".$dat["port"];
        $q = ", ";
      }
      if (MPMU::access($c,"gb.cmd.servers.read.viewrcon",false)) {
        if (isset($dat["rcon-port"])) {
          $ln .= $q.mc::_("rcon-port:%1%",$dat["rcon-port"]);
          $q = ", ";
        }
        if (isset($dat["rcon-pw"])) {
          $ln .= $q.mc::_("rcon-pw:%1%",$dat["rcon-pw"]);
          $q = ", ";
        }
      }
      if (isset($dat["#"])) {
        $ln .= $q.mc::_(" #:%1%",$dat["#"]);
        $q = ", ";
      }
      $txt[] = $ln;
    }
    return $this->paginateText($c,$pageNumber,$txt);
  }
}
<?php
//= cmd:rcon,Server_Management
//: rcon client
//> usage: **rcon** _<id>_ _<command>_
//:
//: This is an rcon client that you can used to send commands to other
//: remote servers identified by **id**.
//:
//: You can specify multiple targets by separating with commas (,).
//: Otherwise, you can use **--all** keyword for the _id_ if you want to
//: send the commands to all configured servers.
//:
//: Use the **servers** command to define the rcon servers.

namespace aliuly\grabbag;

use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\RemoteConsoleCommandSender;
use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\Player;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\RconTask;
use aliuly\grabbag\common\Rcon;
use aliuly\grabbag\common\PermUtils;

class CmdRcon extends BasicCli implements CommandExecutor {
	protected $servers;

	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.rcon", "Rcon client", "op");

		$this->enableCmd("rcon",
							  ["description" => mc::_("RCON client"),
								"usage" => mc::_("/rcon <id> <command>"),
								"permission" => "gb.cmd.rcon"]);
	}
	public function onCommand(CommandSender $c,Command $cmd,$label, array $args) {
		if (count($args) == 0) return false;
		if ($cmd->getName() != "rcon") return false;

		if (count($args) < 2) return false;
		$id = array_shift($args);
		if ($id == "--all") {
			$grp = $this->owner->getModule("ServerList")->getIds();
		} else {
			$grp = [];
			foreach (explode(",",$id) as $i) {
				if ($this->owner->getModule("ServerList")->getServer($i) === null) {
			  	$c->sendMessage(mc::_("%1% does not exist",$id));
			  	continue;
		  	}
				$grp[$i] = $i;
			}
			if (count($grp) == 0) return false;
		}
		$cmd = implode(" ",$args);
		if ($c instanceof RemoteConsoleCommandSender) {
			// This is an Rcon connection itself... we run in the foreground
			foreach ($grp as $id) {
				$dat = $this->owner->getModule("ServerList")->getServer($id);
				if (!isset($dat["rcon-pw"])) {
					$c->sendMessage(mc::_("Peer %1% does not have an rcon password defined", $id));
					continue;
				}
				$host = $dat["host"];
				$port = isset($dat["rcon-port"]) ? $dat["rcon-port"] : $dat["port"];
				$auth = $dat["rcon-pw"];

				$ret = Rcon::connect($host,$port,$auth);
				if (!is_array($ret)) {
					$c->sendMessage($ret);
					continue;
				}
				list($sock,$id) = $ret;
				$ret = Rcon::cmd($cmd,$sock,$id);
				if (is_array($ret)) {
					$c->sendMessage($ret[0]);
				} else {
					$c->sendMessage($ret);
				}
				fclose($sock);
			}
			return true;
		}
		foreach ($grp as $id) {
			$dat = $this->owner->getModule("ServerList")->getServer($id);
			if (!isset($dat["rcon-pw"])) {
				$c->sendMessage(mc::_("Peer %1% does not have an rcon password defined", $id));
				continue;
			}
			$host = $dat["host"];
			$port = isset($dat["rcon-port"]) ? $dat["rcon-port"] : $dat["port"];
			$auth = $dat["rcon-pw"];

			$this->owner->getServer()->getScheduler()->scheduleAsyncTask(
				new RconTask($this->owner,"rconDone",
											[$host,$port,$auth],
											$cmd, [($c instanceof Player) ? $c->getName() : null])

		  );
		}
		return true;
	}
	public function taskDone($res,$sn) {
		if ($sn === null) {
			$player = new ConsoleCommandSender();
		} elseif (($player = $this->owner->getServer()->getPlayer($sn)) == null) {
			return; // Output discarded!
		}
		if (!is_array($res)) {
			$player->sendMessage($res);
			return;
		}
		$player->sendMessage($res[0]);
	}
}
<?php
//= module:repeater
//: Uses **!!** to repeat command with changes
//:
//: If you want to repeat a previous command enter **!!** *without* any "/"
//: in front.  This works for commands and chat messages.
//:
//: You can optionally append additional text to **!!** to do certain
//: things:
//:
//: * **!!** number
//:   - Will let you paginate output.  For example, entering:
//:     - /mw ls
//:     - !!2
//:     - !!3
//:   - This will start showing the output of **/mw ls** and consecutive pages.
//: * **!!** /
//:   - if you forgot the "/" in front, this command will add it.  Example:
//:     - help
//:     - !!/
//: * **!!** _text_
//:   - Will append _text_ to the previous command.  For example:
//:     - /gamemode
//:     - !! survival john
//:   - This will show the usage of survival, the next line will change the
//:     gamemode of john to survival.
//: * **!!** str1 str2
//:   - Will repeat the previous command replacing `str1` with `str2`
//:     Example:
//:     - /give player drt
//:     - !!drt dirt
//:   - This will change **drt** into **dirt**.
//: * **!!^** _text_
//:   - Will insert _text_ at the beginning of the command.
//:
namespace aliuly\grabbag;

use pocketmine\plugin\PluginBase as Plugin;
use pocketmine\event\Listener;
use pocketmine\Player;

use pocketmine\event\player\PlayerCommandPreprocessEvent;
use pocketmine\event\server\RemoteServerCommandEvent;
use pocketmine\event\server\ServerCommandEvent;

use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PermUtils;

class RepeatMgr implements Listener {
	public $owner;

	public function __construct(Plugin $plugin) {
		$this->owner = $plugin;
		PermUtils::add($this->owner, "gb.module.repeater", "use !! to repeat commands", "true");
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
	}
	public function processCmd($msg,$sender) {
		if (preg_match('/^\s*!!/',$msg)) {
			$msg = trim(preg_replace('/^\s*!!\s*/','',$msg));
			// Match !
			$last = $this->owner->getState("RepeatMgr",$sender,false);

			if ($last === false) {
				$sender->sendMessage(mc::_("You do not have any recorded previous command"));
				return false;
			}
			// Just the previous command...
			if ($msg == "") return $last;
			if (is_numeric($msg)) {
				// We need to replace the last word with $msg....
				$words = preg_split('/\s+/',$last);
				if (count($words) == 1) {
					// Only a single world, we append the number...
					$newmsg = $last." ".$msg;
				} else {
					if (is_numeric($words[count($words)-1])) {
						// Exchange the last word (page count)
						$words[count($words)-1] = $msg;
						$newmsg = implode(" ",$words);
					} else {
						// Last word wasn't a number... append one
						$newmsg = $last." ".$msg;
					}
				}
			} elseif ($msg == "/" && substr($last,0,1) != "/") {
				// Forgotten "/"
				$newmsg = "/".$last;
			} elseif (substr($msg,0,1) == "^") {
				// Do we need space?
				if (preg_match('/^\s+/',$msg)) {
					$newmsg = trim(substr($msg,1))." ".$last;
				} else {
					$newmsg = trim(substr($msg,1)).$last;
				}
			} else {
				$words = preg_split('/\s+/',$msg,2);
				if (count($words) > 1
					 && stristr($last,$words[0]) !== false) {
					// Replace string
					$newmsg = str_ireplace($words[0],$words[1],$last);
				} else {
					// Add string...
					$newmsg = $last.' '.$msg;
				}
			}
			if (!($sender instanceof Player)) $sender->sendMessage(">> $newmsg");

			$last = $this->owner->setState("RepeatMgr",$sender,$newmsg);
			return $newmsg;
		}
		$last = $this->owner->setState("RepeatMgr",$sender,$msg);
		return false;
	}

	/**
	 * @priority LOWEST
	 */
	public function onPlayerCmd(PlayerCommandPreprocessEvent $ev) {
		if ($ev->isCancelled()) return;
		if (!$ev->getPlayer()->hasPermission("gb.module.repeater")) return;
		$res = $this->processCmd($ev->getMessage(),$ev->getPlayer());
		if ($res === false) return;
		$ev->setMessage($res);
	}
	/**
	 * @priority LOWEST
	 */
	public function onRconCmd(RemoteServerCommandEvent $ev) {
		$res = $this->processCmd($ev->getCommand(),$ev->getSender());
		if ($res === false) return;
		$ev->setCommand($res);
	}
	/**
	 * @priority LOWEST
	 */
	public function onConsoleCmd(ServerCommandEvent $ev) {
		$res = $this->processCmd($ev->getCommand(),$ev->getSender());
		if ($res === false) return;
		$ev->setCommand($res);
	}
}
<?php
//= cmd:crash,Server_Management
//: manage crash dumps
//> usage: **crash** _[ls|clean|show]_
//:
//: Will show the number of **crash** files in the server.
//: The following optional sub-commands are available:
//: - **crash** **count**
//:   - Count the number of crash files
//: - **crash** **ls** _[pattern]_
//:   - List crash files
//: - **crash** **clean** _[pattern]_
//:   - Delete crash files
//: - **show** _[pattern]_
//:   - Shows the crash file ##

namespace aliuly\grabbag;

use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\utils\TextFormat;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PermUtils;

class CmdCrash extends BasicCli implements CommandExecutor {
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.crash", "crash dump management", "op");
		$this->enableCmd("crash",
							  ["description" => mc::_("manage crash files"),
								"usage" => mc::_("/crash [count|clean|show|ls]"),
								"permission" => "gb.cmd.crash"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "crash") return false;
		if (count($args) == 0) $args = [ "count" ];
		$scmd = strtolower(array_shift($args));

		switch($scmd) {
			case "count":
				return $this->cmdCount($sender);
			case "clean":
				return $this->cmdClean($sender,$args);
			case "show":
				return $this->cmdShow($sender,$args);
			case "ls":
				return $this->cmdLs($sender,$args);
				break;
			default:
				$sender->sendMessage(mc::_("Unknown sub-command %1%",$scmd));
		}
		return false;
	}
	private function getCrashDumps($pattern = "*") {
		return glob($this->owner->getServer()->getDataPath()."CrashDump_$pattern.log");
	}
	private function cmdCount(CommandSender $c) {
		$cnt = count($this->getCrashDumps());
		$c->sendMessage(mc::_("Total Crash Dumps: %1%",$cnt));
		return true;
	}
	private function cmdClean(CommandSender $c,$args) {
		if (count($args) == 0) $args[] = "*";
		if (count($args) != 1) return false;
		$cnt = 0;
		foreach ($this->getCrashDumps($args[0]) as $cd) {
			if (is_file($cd)) {
				unlink($cd);
				++$cnt;
			}
		}
		$c->sendMessage(mc::_("Crash Dumps Deleted: %1%",$cnt));
		return true;
	}
	private function cmdLs(CommandSender $c,$args) {
		$pageNumber = $this->getPageNumber($args);
		if (count($args) == 0) $args[] = "*";
		if (count($args) != 1) return false;
		$dumps = $this->getCrashDumps($args[0]);
		if (count($dumps) == 0) {
			$c->sendMessage(mc::_("No crash dumps found"));
			return true;
		}
		$i = 1;
		$txt = [ mc::_("Crash Dumps: %1%",count($dumps)) ];
		foreach ($dumps as $dump) {
			$txt[] = mc::_("%1%: %2%", $i++,
								preg_replace('/^CrashDump_/','',basename($dump)));
		}
		return $this->paginateText($c,$pageNumber,$txt);
	}
	private function cmdShow(CommandSender $c,$args) {
		$pageNumber = $this->getPageNumber($args);
		if (count($args) == 0) $args[] = "*";
		if (count($args) != 1) return false;
		$dumps = $this->getCrashDumps($args[0]);
		if (count($dumps) == 0) {
			$c->sendMessage(mc::_("No crash dumps found"));
			return true;
		}
		$f = array_shift($dumps);
		$txt = file($f,FILE_IGNORE_NEW_LINES);
		array_unshift($txt,mc::_("Crash Dump %1%",
										 preg_replace('/^CrashDump_/','',basename($f))));
		if (count($dumps) > 0) {
			array_unshift($txt,TextFormat::RED.
							  mc::_("Multiple matches, showing first match!"));
		}
		return $this->paginateText($c,$pageNumber,$txt);
	}
}
<?php
//= cmd:pluginmgr,Server_Management
//: manage plugins
//> usage: **pluginmgr** _<subcmd>_ _<plugin>_
//:
//: Manage plugins.
//:  The following sub-commands are available:
//> - **pluginmgr** **enable** _<plugin>_
//:     - Enable a disabled plugin.
//> - **pluginmgr** **disable** _<plugin>_
//:     - Disables an enabled plugin.
//> - **pluginmgr** **reload** _<plugin>_
//:     - Disables and enables a plugin.
//> - **pluginmgr** **info** _<plugin>_
//:     - Show plugin details
//> - **pluginmgr** **commands** _<plugin>_
//:     - Show commands registered by plugin
//> - **pluginmgr** **permissions** _<plugin>_
//:     - Show permissions registered by plugin
//> - **pluginmgr** **load** _<path>_
//:     - Load a plugin from file path (presumably outside the **plugin** folder.)
//> - **pluginmgr** **dumpmsg** _<plugin>_ _[lang]_
//:     - Dump messages.ini.
//> - **pluginmgr** **uninstall** _<plugin>_
//:     - Uninstall plugin.
//> - **pluginmgr** **feature** _<plugin>_ _[[-|+]feature]_
//:     - For plugins that have a _features_ table in **config.yml**
//:       this will let you change those settings.

namespace aliuly\grabbag;

use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\utils\TextFormat;

use pocketmine\plugin\Plugin;
use pocketmine\plugin\PluginManager;
use pocketmine\plugin\PluginDescription;
use pocketmine\utils\Config;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PermUtils;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\FileUtils;

class CmdPluginMgr extends BasicCli implements CommandExecutor {
	private function findPlugin($path) {
		if (file_exists($path)) return $path;
		$srv = $this->owner->getServer();
		foreach ([$srv->getPluginPath(),$srv->getDataPath(),$srv->getFilePath()] as $d) {
			if (file_exists($d.'/'.$path)) return $d.'/'.$path;
		}
		return $path;
	}
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.pluginmgr", "Run-time management of plugins", "op");
		$this->enableCmd("pluginmgr",
							  ["description" => mc::_("manage plugins"),
								"usage" => mc::_("/pluginmgr <enable|disable|reload|info|commands|permissions|load|dumpmsg|uninstall|feature> <plugin>"),
								"aliases" => ["pm"],
								"permission" => "gb.cmd.pluginmgr"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "pluginmgr") return false;
		$pageNumber = $this->getPageNumber($args);
		if (count($args) < 2) return false;

		$scmd = strtolower(array_shift($args));
		$pname = array_shift($args);

		$mgr = $this->owner->getServer()->getPluginManager();
		if ($scmd == "load" || $scmd == "ld") {
			$pname = $this->findPlugin($pname);
			if (!file_exists($pname)) {
				$sender->sendMessage(TextFormat::RED.mc::_("%1%: Not found",$pname));
				return true;
			}
			$plugin = $mgr->loadPlugin($pname);
			if ($plugin === null) {
				$sender->sendMessage(TextFormat::RED.mc::_("Unable to load plugin from %1%",$pname));
				return true;
			}
			$sender->sendMessage(TextFormat::BLUE.mc::_("Loaded plugin %1%", $plugin->getDescription()->getFullName()));
			$mgr->enablePlugin($plugin);
			return true;
		}

		$plugin = $mgr->getPlugin($pname);
		if ($plugin === null) {
			$sender->sendMessage(TextFormat::RED.mc::_("Plugin %1% not found",
																	 $pname));
			return true;
		}

		switch($scmd) {
			case "ena":
			case "start":
			case "enable":
				if ($plugin->isEnabled()) {
					$sender->sendMessage(TextFormat::RED.
												mc::_("%1% is already enabled",$pname));
					break;
				}
				$mgr->enablePlugin($plugin);
				$sender->sendMessage(TextFormat::GREEN.
											mc::_("Plugin %1% enabled",$pname));
				break;
			case "disable":
			case "dis":
			case "stop":
				if (!$plugin->isEnabled()) {
					$sender->sendMessage(TextFormat::RED.
												mc::_("%1% is already disabled",$pname));
					break;
				}
				$mgr->disablePlugin($plugin);
				$sender->sendMessage(TextFormat::GREEN.
											mc::_("Plugin %1% disabled",$pname));

				break;
			case "reload":
			case "restart":
			case "reenable":
			case "re":
				if (!$plugin->isEnabled()) {
					$sender->sendMessage(TextFormat::RED.
												mc::_("%1% is not enabled",$pname));
					break;
				}
				$mgr->disablePlugin($plugin);
				$mgr->enablePlugin($plugin);
				$sender->sendMessage(TextFormat::GREEN.
											mc::_("Plugin %1% reloaded",$pname));
				break;
			case "info":
				return $this->cmdInfo($sender,$plugin,$pageNumber);
			case "cmds":
			case "com":
			case "command":
			case "commands":
				return $this->cmdCmds($sender,$plugin,$pageNumber);
			case "perms":
			case "permission":
			case "permissions":
				return $this->cmdPerms($sender,$plugin,$pageNumber);
			case "dumpmsg":
			case "dumpmsgs":
				return $this->cmdDumpMsgs($sender,$plugin, $args);
			case "uninstall":
				return $this->cmdRemove($sender,$plugin,$mgr);
			case "feature":
				return $this->cmdFeatures($sender,$plugin, $mgr, $args, $pageNumber);
			default:
				$sender->sendMessage(mc::_("Unknown sub-command %1%",$scmd));
				return false;
		}
		return true;
	}
	private function cmdFeatures(CommandSender $c,Plugin $plugin, $mgr, $args, $pageNumber) {
		//
		$cfgfile = $plugin->getDataFolder()."config.yml";
		if (!file_exists($cfgfile)) {
			$c->sendMessage(mc::_("%1%: Does not have config.yml", $plugin->getDescription()->getFullName()));
			return true;
		}
		$cfg = (new Config($cfgfile,Config::YAML,[]))->getAll();
		$section = "features";
		if (!isset($cfg[$section]) || !is_array($cfg[$section])) {
			$c->sendMessage(mc::_("%1%: Does not have compatible config.yml", $plugin->getDescription()->getFullName()));
			return true;
		}
		if (count($args) == 0) {
			$txt = [];
			$txt[] = mc::_("%1% Features", $plugin->getDescription()->getFullName());
			foreach ($cfg[$section] as $a => $b) {
				if (is_bool($b)) {
					$txt[] = TextFormat::AQUA.$a.TextFormat::WHITE.": ". ($b ? TextFormat::GREEN.mc::_("yes") : TextFormat::YELLOW. mc::_("no"));
					if (isset($cfg[$section]["# ".$b])) {
						$txt[] = TextFormat::BLUE."    ".$cfg[$section]["# ".$b];
					}
				}
			}
			return $this->paginateText($c,$pageNumber,$txt);
		}
		$bounce = false;
		foreach ($args as $i) {
			$v = true;
			if ($i{0} == "+") {
				$i = substr($i,1);
			} elseif ($i{0} == "-") {
				$v = false;
				$i = substr($i,1);
			}
			if (!isset($cfg[$section][$i]) || !is_bool($cfg[$section][$i])) {
				$c->sendMessage(mc::_("%1%: Does not support feature %2%", $plugin->getDescription()->getFullName(), $i));
				continue;
			}
			if ($cfg[$section][$i] === $v) continue;
			$cfg[$section][$i] = $v;
			if ($v) {
				$c->sendMessage(mc::_("Enabling %1%",$i));
			} else {
				$c->sendMessage(mc::_("Disabling %1%",$i));
			}
			$bounce = true;
		}
		if (!$bounce) {
			$c->sendMessage(mc::_("No changes"));
			return true;
		}
		$yaml = new Config($cfgfile,Config::YAML,[]);
		$yaml->setAll($cfg);
		$yaml->save();
		$mgr->disablePlugin($plugin);
		$mgr->enablePlugin($plugin);
		$c->sendMessage(TextFormat::GREEN.
									mc::_("Plugin %1% reloaded",$plugin->getDescription()->getFullName()));
		return true;
	}
	private function cmdDumpMsgs(CommandSender $c,Plugin $plugin, $args) {
		if (count($args) > 1) return false;
		$lang = count($args) == 1 ? $args[0] : "messages";
		$file = $this->getPluginFilePath($plugin)."/resources/messages/".$lang.".ini";
		if (!file_exists($file)) {
			$c->sendMessage(mc::_("Missing language file %1%", $lang));
			return true;
		}
		$txt = file_get_contents($file);
		if (!is_dir($plugin->getDataFolder())) mkdir($plugin->getDataFolder());
		if (file_put_contents($plugin->getDataFolder()."messages.ini",$txt)) {
			$c->sendMessage(mc::_("messages.ini created"));
		} else {
			$c->sendMessage(mc::_("Error dumping messages.ini"));
		}
		return true;
	}
	private function cmdPerms(CommandSender $c,Plugin $p,$pageNumber) {
		$desc = $p->getDescription();
		$perms = $desc->getPermissions();
		if (count($perms) == 0) {
			$c->sendMessage(TextFormat::RED,mc::_("%1% has no configured permissions",
															  $p->getName()));
			return true;
		}
		$txt = [];
		$txt[] = TextFormat::AQUA.mc::_("Plugin: %1%",$desc->getFullName());
		foreach ($perms as $p) {
			$txt[] = TextFormat::GREEN.$p->getName().": ".
					 TextFormat::WHITE.$p->getDescription();
		}
		return $this->paginateText($c,$pageNumber,$txt);
	}
	private function cmdCmds(CommandSender $c,Plugin $p,$pageNumber) {
		$desc = $p->getDescription();
		$cmds = $desc->getCommands();
		if (count($cmds) == 0) {
			$c->sendMessage(TextFormat::RED,mc::_("%1% has no configured commands",
															  $p->getName()));
			return true;
		}
		$txt = [];
		$txt[] = TextFormat::AQUA.mc::_("Plugin: %1%",$desc->getFullName());
		foreach ($cmds as $i=>$j) {
			$d = isset($j["description"]) ? $j["description"] : "";
			$txt[] = TextFormat::GREEN.$i.": ".TextFormat::WHITE.$d;
		}
		return $this->paginateText($c,$pageNumber,$txt);
	}

	private function cmdInfo(CommandSender $c,Plugin $p,$pageNumber) {
		$txt = [];
		$desc = $p->getDescription();
		$txt[] = TextFormat::AQUA.mc::_("Plugin: %1%",$desc->getFullName());
		if ($desc->getDescription())
			$txt[] = TextFormat::GREEN.mc::_("Description: ").
					 TextFormat::WHITE.$desc->getDescription();
		if ($desc->getPrefix())
			$txt[] = TextFormat::GREEN.mc::_("Prefix: ").
					 $txt[] = TextFormat::GREEN.mc::_("Main Class: ").
					 TextFormat::WHITE.$desc->getMain();
		if ($desc->getWebsite())
			$txt[] = TextFormat::GREEN.mc::_("WebSite: ").
					 TextFormat::WHITE.$desc->getWebsite();
		if (count($desc->getCompatibleApis()))
			$txt[] = TextFormat::GREEN.mc::_("APIs: ").
					 TextFormat::WHITE.implode(TextFormat::BLUE.", ".TextFormat::WHITE,$desc->getCompatibleApis());
		if (count($desc->getAuthors()))
			$txt[] = TextFormat::GREEN.mc::_("Authors: ").
					 TextFormat::WHITE.implode(TextFormat::BLUE.", ".TextFormat::WHITE,$desc->getAuthors());
		if (count($desc->getDepend()))
			$txt[] = TextFormat::GREEN.mc::_("Dependancies: ").
					 TextFormat::WHITE.implode(TextFormat::BLUE.", ".TextFormat::WHITE,$desc->getDepend());
		if (count($desc->getSoftDepend()))
			$txt[] = TextFormat::GREEN.mc::_("Soft-Dependancies: ").
					 TextFormat::WHITE.implode(TextFormat::BLUE.", ".TextFormat::WHITE,$desc->getSoftDepend());
		if (count($desc->getLoadBefore()))
			$txt[] = TextFormat::GREEN.mc::_("Load Before: ").
					 TextFormat::WHITE.implode(TextFormat::BLUE.", ".TextFormat::WHITE,$desc->getLoadBefore());
		if (($cnt = count($desc->getCommands())) > 0)
			$txt[] = TextFormat::GREEN.mc::_("Commands: ").TextFormat::WHITE.$cnt;
		if (($cnt = count($desc->getPermissions())) > 0)
			$txt[] = TextFormat::GREEN.mc::_("Permissions: ").TextFormat::WHITE.$cnt;
		$loader = explode("\\",get_class($p->getPluginLoader()));
		$txt[] = TextFormat::GREEN.mc::_("PluginLoader: ").TextFormat::WHITE.
					array_pop($loader);

		$file = $this->getPluginFilePath($p);
		$txt[] = TextFormat::GREEN.mc::_("FileName: ").TextFormat::WHITE.$file;

		return $this->paginateText($c,$pageNumber,$txt);
	}
	private function cmdRemove(CommandSender $c,Plugin $plugin,$mgr) {
		$file = $this->getPluginFilePath($plugin);
		// Check the different types...
		if (($fp = MPMU::startsWith($file,"phar:")) !== null) {
			// This is a phar plugin file
			$file = $fp;
			$c->sendMessage(mc::_("Uninstalled PHAR plugin from %1%", $file));
		} elseif (($fp = MPMU::startsWith($file,"myzip:")) !== null) {
			// This is a zip plugin
			$fp = explode("#",$fp);
			array_pop($fp);
			$file = implode("#",$fp);
			$c->sendMessage(mc::_("Uninstalled Zip plugin from %1%", $file));
		} elseif (is_dir($file)) {
			// A Folder plugin from devtools
			$c->sendMessage(mc::_("Uninstalled Folder plugin from %1%", $file));
		} elseif (is_file($file)) {
			// A Script plugin
			$c->sendMessage(mc::_("Uninstalled Script plugin from %1%", $file));
		} else {
			$loader = explode("\\",get_class($plugin->getPluginLoader()));
			$c->sendMessage(mc::_("Unsupported loader %1% for uninstall", array_pop($loader)));
			return true;
		}
		$mgr->disablePlugin($plugin);
		if (FileUtils::rm_r($file)) {
			$c->sendMessage(TextFormat::GREEN.mc::_("Uninstalled!"));
			$c->sendMessage(mc::_("It is recommended to re-start the server as"));
			$c->sendMessage(mc::_("there may be lingering references pointing"));
			$c->sendMessage(mc::_("to the old plugin."));
		} else {
			$c->sendMessage(TextFormat::RED.mc::_("Uninstall failed"));
		}
		return true;
	}

	protected function getPluginFilePath(Plugin $p) {
		$reflex = new \ReflectionClass("pocketmine\\plugin\\PluginBase");
		$file = $reflex->getProperty("file");
		$file->setAccessible(true);
		$file = $file->getValue($p);
		$file = preg_replace("/\/*\$/","",$file);
		return $file;
	}
}
<?php
//= cmd:perm,Player_Management
//: temporarily change player's permissions
//> usage: **perm** _<player>_ _<dump|permission>_ _[true|false]_
//:
//: This can be used to temporarily change player's permissions.
//: Changes are only done in-memory, so these will revert if the
//: disconnects or the server reloads.
//: You can specify a _permission_ and it will show it's value or
//: if true|false is specified it will be changed.
//: If you specify **dump**, it will show all permissions
//: associated to a player.

namespace aliuly\grabbag;

use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\utils\TextFormat;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerQuitEvent;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\PermUtils;

class CmdPermMgr extends BasicCli implements CommandExecutor,Listener {
	protected $perms;

	public function __construct($owner) {
		parent::__construct($owner);
		$this->perms = [];

		PermUtils::add($this->owner, "gb.cmd.permmgr", "Manipulate Permissions", "op");

		$this->enableCmd("perm",
							  ["description" => mc::_("change permissions"),
								"usage" => mc::_("/perm <player> <dump|permission> [true|false]"),
								"permission" => "gb.cmd.permmgr"]);
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
	}
	public function onQuit(PlayerQuitEvent $ev) {
		$pl = $ev->getPlayer();
		$n = strtolower($pl->getName());
		if (isset($this->perms[$n])) {
			$attach = $this->perms[$n];
			unset($this->perms[$n]);
			$pl->removeAttachment($attach);
		}
	}

	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "perm") return false;
		$pageNumber = $this->getPageNumber($args);
		if (count($args) < 2) return false;

		$target = $this->owner->getServer()->getPlayer($args[0]);
		if ($target == null) {
			$sender->sendMessage(TextFormat::RED.mc::_("%1%: Not found",$args[0]));
			return true;
		}
		array_shift($args);
		if (strtolower($args[0]) == "dump") {
			if (count($args) != 1) return false;
			$txt = [ TextFormat::YELLOW.mc::_("Permissions for %1%", $target->getName()) ];
			$target->recalculatePermissions();
			foreach ($target->getEffectivePermissions() as $pp) {

				$txt[] = TextFormat::GREEN.$pp->getPermission() .": ".
						 TextFormat::WHITE.($pp->getValue()
												  ? mc::_("YES") : mc::_("NO"));
			}
			return $this->paginateText($sender,$pageNumber,$txt);
		}
		$perm = array_shift($args);
		if (count($args) > 1) return false;
		if (count($args) == 1) {
			$bool = filter_var(array_shift($args), FILTER_VALIDATE_BOOLEAN);

			$n = strtolower($target->getName());
			if (!isset($this->perms[$n])) {
				$this->perms[$n] = $target->addAttachment($this->owner);
			}
			$at = $this->perms[$n];
			$at->setPermission($perm,$bool);
		}
		$sender->sendMessage(TextFormat::YELLOW.$target->getName().",".
									TextFormat::GREEN.$perm.": ".
									TextFormat::WHITE.($target->hasPermission($perm)
															 ? mc::_("YES") : mc::_("NO")));
		return true;
	}
}
<?php
//= cmd:throw,Trolling
//: Throw a player in the air
//> usage: **throw** _<player>_ _[force]_

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\math\Vector3;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

class CmdThrow extends BasicCli implements CommandExecutor {
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.throw", "Troll players", "op");

		$this->enableCmd("throw",
							  ["description" => mc::_("Throw player up in the air"),
								"usage" => mc::_("/throw <player> [force]"),
								"permission" => "gb.cmd.throw"]);
	}
	public function throwPlayer($pl) {
		if (MPMU::apiVersion("1.12.0")) {
			$pl->teleport(new Vector3($pl->getX(),128,$pl->getZ()));
		} else {
			$force = 64;
			if (isset($args[1])) $force = intval($args[1]);
			if ($force <= 4) $force = 64;

			$pl->setMotion(new Vector3(0,$force,0));
		}

	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "throw") return false;
		if (count($args) > 2 || count($args) == 0) return false;
		$pl = $this->owner->getServer()->getPlayer($args[0]);
		if (!$pl) {
			$sender->sendMessage(mc::_("%1% not found",$args[0]));
			return true;
		}
		$this->throwPlayer($pl);
		return true;
	}
}
<?php
//= cmd:reg,Player_Management
//: Manage player registrations
//> usage: **reg** _[subcommand]_ _[options]_
//:
//: By default it will show the number of registered players.  The following
//: sub-commands are available:
//> - **count**
//:   - default sub-command.  Counts the number of registered players.
//> - **list** _[pattern]_
//:   - Display a list of registered players or those that match the
//:     wildcard _pattern_.
//> - **rm** _<player>_
//:   - Removes _player_ registration.
//> - **since** _<when>_
//:   - Display list of players registered since a date/time.


namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\Player;
use pocketmine\utils\TextFormat;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;


class CmdRegMgr extends BasicCli implements CommandExecutor {

	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.regs", "Manage player registrations", "op");
		$this->enableCmd("reg",
							  ["description" => mc::_("manage player registrations"),
								"usage" => mc::_("/reg [count|list [pattern]|rm [player]|since <when>]"),
								"permission" => "gb.cmd.regs"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if ($cmd->getName() != "reg") return false;
		if (count($args) == 0) $args = [ "count" ];
		$scmd = strtolower(array_shift($args));
		switch ($scmd) {
			case "count":
				if (count($args) != 0) return false;
				$cnt = count(glob($this->owner->getServer()->getDataPath()."players/*.dat"));
				$sender->sendMessage(mc::n(mc::_("One player registered"),
													mc::_("%1% players registered",$cnt),
													$cnt));
				return true;
			case "ls":
			case "list":
				$pageNumber = $this->getPageNumber($args);
				if (count($args) == 0) {
					$pattern = "*";
				} elseif (count($args) == 1) {
					$pattern = implode(" ",$args);
				} else {
					return false;
				}
				$f = glob($this->owner->getServer()->getDataPath()."players/".
							 $pattern.".dat");
				$txt = [ mc::n(mc::_("One player found"),
									mc::_("%1% players found",count($f)),count($f)) ];
				$cols = 8;
				$i = 0;
				foreach ($f as $n) {
					$n = basename($n,".dat");
					if (($i++ % $cols) == 0) {
						$txt[] = $n;
					} else {
						$txt[count($txt)-1] .= ", ".$n;
					}
				}
				return $this->paginateText($sender,$pageNumber,$txt);
			case "rm":
				if (count($args) != 1) return false;
				$victim = strtolower(array_shift($args));
				$target = $this->owner->getServer()->getPlayer($victim);
				if ($target !== null) {
					$sender->sendMessage(TextFormat::RED.
												mc::_("Can not delete player re-gistration while they are on-line"));
					return true;
				}
				$target = $this->owner->getServer()->getOfflinePlayer($victim);
				if ($target == null || !$target->hasPlayedBefore()) {
					$sender->sendMessage(mc::_("%1% can not be found.",$victim));
					return true;
				}
				$f = $this->owner->getServer()->getDataPath()."players/".$victim.".dat";
				if (!is_file($f)) {
					$sender->sendMessage(TextFormat::RED.mc::_("Problem deleting %1%",$victim));
					return true;
				}
				unlink($f);
				$sender->sendMessage(TextFormat::RED.mc::_("%1% was deleted.",$victim));
				return true;
			case "since":
				$pageNumber = $this->getPageNumber($args);
				if (count($args) == 0) return false;
				if (($when = strtotime(implode(" ",$args))) === false) return false;
				$f = glob($this->owner->getServer()->getDataPath()."players/*.dat");
				$tab = [ [ mc::_("Date/Time"), "x" ] ];
				foreach ($f as $n) {
					$n = basename($n,".dat");
					$target = $this->owner->getServer()->getOfflinePlayer($n);
					if ($target == null || !$target->hasPlayedBefore()) continue;
					if (($regdate = $target->getFirstPlayed()/1000) > $when) {
						$tab[] = [ date(mc::_("d-M-Y H:i"),$regdate), $n ];
					}
				}
				$cnt = count($tab)-1;
				if ($cnt == 0) {
					$sender->sendMessage(mc::_("No players found"));
					return true;
				}
				$tab[0][1] = mc::n(mc::_("One player found"),
														mc::_("%1% players found",$cnt),
														$cnt);
				return $this->paginateTable($sender,$pageNumber,$tab);

		}
		return false;
	}
}
<?php
//= cmd:chat-on|chat-off,Trolling
//: Allow players to opt-out from chat
//> usage: **chat-on|chat-off** _[player|--list|--server]_
//:
//: Prevents players from sending/receiving chat messages.
//: The following options are recognized:
//: - --list : Lists the players that have chat on/off status
//: - --server : Globally toggles on/off chat.
//:
//= cmd:clearchat,Player_Management
//: Clears your chat window
//> usage: **clearchat**
//:
//= cmd:nick,Player_Management
//: Change your display name
//> usage: **nick** _<name>_

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerChatEvent;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

class CmdChatMgr extends BasicCli implements Listener,CommandExecutor {
	protected $chat;

	public function __construct($owner) {
		parent::__construct($owner);
		$this->chat = true;

		PermUtils::add($this->owner, "gb.cmd.togglechat", "lets players opt out from chat", "true");
		PermUtils::add($this->owner, "gb.cmd.togglechat.others", "lets you toggle chat for others", "op");
		PermUtils::add($this->owner, "gb.cmd.togglechat.excempt", "chat-off players will always receive chats from these players", "op");
		PermUtils::add($this->owner, "gb.cmd.togglechat.global", "Can toggle chat for the server as a whole", "op");
		PermUtils::add($this->owner, "gb.cmd.clearchat", "Clear your chat window", "true");
		PermUtils::add($this->owner, "gb.cmd.nick", "Change display name", "true");

		$this->enableCmd("clearchat",
										["description" => mc::_("clears your chat window"),
										"usage" => mc::_("/clearchat"),
										"permission" => "gb.cmd.clearchat"]);
		$this->enableCmd("chat-on",
										["description" => mc::_("starts chat"),
										"usage" => mc::_("/chat-on [player|-l|-g]"),
										"permission" => "gb.cmd.togglechat"]);
		$this->enableCmd("chat-off",
										["description" => mc::_("stops chat"),
										"usage" => mc::_("/chat-off [player|-l|-g]"),
										"permission" => "gb.cmd.togglechat"]);
		$this->enableCmd("nick",
										["description" => mc::_("change displayed name"),
										"usage" => mc::_("/nick <new-name>"),
										"permission" => "gb.cmd.nick"]);

		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
	}

	public function setGlobalChat($mode) {
		$this->chat = $mode;
	}
	public function getGlobalChat() {
		return $this->chat;
	}
	public function setPlayerChat($player,$mode) {
		$this->setState($player,!$mode);
	}
	public function getPlayerChat($player) {
		return !$this->getState($to,false);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		switch ($cmd->getName()) {
			case "nick":
				if (!MPMU::inGame($sender)) return true;
				if (count($args) == 0) {
					$sender->sendMessage(mc::_("Current nick is: %1%",$sender->getDisplayName()));
					return true;
				}
				if (count($args) !== 1)  return false;
				$this->owner->getServer(mc::_("%1% is now known as %2%",$sender->getDisplayName(),$args[0]));
				$sender->setDisplayName($args[0]);
				return true;
			case "clearchat":
		  	if (!MPMU::inGame($sender)) return true;
				if (count($args) != 0) return false;
				for($i=0;$i<32;++$i) $sender->sendMessage(" ");
				return true;
			case "chat-on":
			case "chat-off":
		  	if (count($args) > 0) {
		 			switch ($n = strtolower(array_shift($args))) {
						case "--list":
						case "--ls":
						case "-l":
						  if (!MPMU::access($sender,"gb.cmd.togglechat.others")) return true;
							$pageNumber = $this->getPageNumber($args);
							$txt = [ "" ];
							$cols = 8;
							$i = 0;
							foreach ($this->owner->getServer()->getOnlinePlayers() as $p) {
								if (!$this->getState($p,false)) continue;
								$n = $p->getDisplayName();
								if (($i++ % $cols) == 0) {
									$txt[] = $n;
								} else {
									$txt[count($txt)-1] .= ", ".$n;
								}
							}
							if ($i == 0) {
								$sender->sendMessage(mc::_("No players with chat off"));
								if (!$this->chat) $sender->sendMessage(mc::_("Chat is GLOBALLY off"));
								return true;
							}
							if ($this->chat) {
								$txt[0] = mc::n(mc::_("One player with chat off"),
																mc::_("%1% players with chat off",$i),
																$i);
							} else {
								$txt[0] = mc::_("Chat is GLOBALLY off");
							}
							return $this->paginateText($sender,$pageNumber,$txt);
						case "--server":
						case "--global":
						case "-g":
							if (count($args)) return false;
							if (!MPMU::access($sender,"gb.cmd.togglechat.global")) return true;
							if ($cmd->getName() == "chat-off") {
								$this->setGlobalChat(false);
								$this->owner->getServer()->broadcastMessage(mc::_("Chat disabled globally from %1%", $sender->getName()));
							} else {
								$this->setGlobalChat(true);
								$this->owner->getServer()->broadcastMessage(mc::_("Chat enabled globally from %1%", $sender->getName()));
							}
							return true;
						default:
							if (count($args)) return false;
							if (!MPMU::access($sender,"gb.cmd.togglechat.others")) return true;
							$player = $this->owner->getServer()->getPlayer($n);
							if ($player === null) {
								$sender->sendMessage(mc::_("Unable to find %1%",$n));
								return true;
							}
							if ($cmd->getName() == "chat-off") {
								$this->setState($player, true);
								$player->sendMessage(mc::_("Chat disabled from %1%",$sender->getName()));
								$sender->sendMessage(mc::_("Chat disabled for %1%",$player->getDisplayName()));
							} else {
								$this->unsetState($player);
								$player->sendMessage(mc::_("Chat enabled from %1%",$sender->getName()));
								$sender->sendMessage(mc::_("Chat enabled for %1%",$player->getDisplayName()));
							}
							return true;
						}
						return false;
				}
				if (!MPMU::inGame($sender)) return true;
				if ($cmd->getName() == "chat-off") {
					$this->setState($sender,true);
					$sender->sendMessage(mc::_("Chat disabled"));
				} else {
					$this->unsetState($sender);
					$sender->sendMessage(mc::_("Chat enabled"));
				}
				return true;
		}
		return false;
	}

	public function onChat(PlayerChatEvent $ev) {
		if ($ev->isCancelled()) return;
		$p = $ev->getPlayer();
		if ($p->hasPermission("gb.cmd.togglechat.excempt")) return; // Can always chat!
		if (!$this->chat) {
			$p->sendMessage(mc::_("Chat has been globally disabled!"));
			$ev->setCancelled();
			return;
		}
		if ($this->getState($p,false)) {
			$p->sendMessage(mc::_("You have chat disabled!  Use /chat-on"));
			$ev->setCancelled();
			return;
		}
		$recvr = [];
		foreach ($ev->getRecipients() as $to) {
			if ($this->getState($to,false)) continue;
			$recvr[] = $to;
		}
		$ev->setRecipients($recvr);
	}
}
<?php
//= cmd:query,Server_Management
//: query remote servers
//> usage: **query** **[list|info|plugins|players|summary]** _[opts]_
//:
//: This is a query client that you can use to query other
//: remote servers.
//:
//: Servers are defined with the **servers** command.
//:
//: Options:
//> - **query list**
//:     - List players on all configured `query` connections.
//> - **query info** _<id>_
//:     - Return details from query
//> - **query players** _<id>_
//:     - Return players on specified server
//> - **query plugins** _<id>_
//:     - Returns plugins on specified server
//> - **query summary**
//:     - Summary of server data

namespace aliuly\grabbag;

use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\utils\TextFormat;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

use xPaw\MinecraftQuery;
use xPaw\MinecraftQueryException;

class CmdQuery extends BasicCli implements CommandExecutor {

	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.query", "Query command", "true");
		PermUtils::add($this->owner, "gb.cmd.query.details", "View details (info, plugins)", "true");
		PermUtils::add($this->owner, "gb.cmd.query.players", "View players", "true");
		PermUtils::add($this->owner, "gb.cmd.query.players.showip", "View players server IP", "true");
		PermUtils::add($this->owner, "gb.cmd.query.list", "Query List sub command", "true");

		$this->enableCmd("query",
							  ["description" => mc::_("Query servers"),
								"usage" => mc::_("/query [list|info|plugins|players|summary] <opts>"),
								"permission" => "gb.cmd.query"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		if (count($args) == 0) $args = ["summary"];
		switch($cmd->getName()) {
			case "query":
				switch ($n = strtolower(array_shift($args))) {
					case "info":
					case "plugins":
						if (!MPMU::access($sender,"gb.cmd.query.details")) return true;
						return $this->cmdQuery($sender,$n,$args);
					case "players":
						if (!MPMU::access($sender,"gb.cmd.query.players")) return true;
						$pageNumber = $this->getPageNumber($args);
					  if (count($args) && $sender->hasPermission("gb.cmd.query.players.showip")) {
							return $this->cmdQuery($sender,$n,$args,$pageNumber);
						}
						return $this->cmdPlayers($sender,$pageNumber);
					case "list":
							if (!MPMU::access($sender,"gb.cmd.query.list")) return true;
							$pageNumber = $this->getPageNumber($args);
							return $this->cmdListAll($sender,$pageNumber);
					case "summary":
					  return $this->cmdSummary($sender);
				}
		}
		return false;
	}
	private function cmdQuery(CommandSender $c,$q,$args,$pageNumber = -1) {
		if ($pageNumber == -1) $pageNumber = $this->getPageNumber($args);
		if (count($args) != 1) {
			$c->sendMessage(TextFormat::RED.mc::_("Usage: %1% <id>",$q));
			return false;
		}
		$id = array_shift($args);
		if (($dat = $this->owner->getModule("ServerList")->getServer($id)) === null) {
			$c->sendMessage(TextFormat::RED.mc::_("%1% does not exist",$id));
			return false;
		}
		$host = $dat["host"];
		$port = $dat["port"];

		$Query = new MinecraftQuery( );
		try {
			$Query->Connect( $host, $port, 1 );
		} catch (MinecraftQueryException $e) {
			$c->sendMessage(TextFormat::RED.mc::_("Query %1% failed: %2%",$host,$e->getMessage()));
			return true;
		}
		$txt = [ mc::_("[%3%] query for %1%:%2%", $host,$port,$q) ];
		switch ($q) {
			case "info":
			  if (($info = $Query->GetInfo()) === false) {
					$c->sendMessage(TextFormat::RED.mc::_("Query of %1%:%2% returned no data", $host,$port));
					return true;
				}
				foreach ($info as $i=>$j) {
					if ($i == "RawPlugins") continue;
					if (is_array($j)) continue;
					$txt[] =  TextFormat::GREEN. $i.": ".TextFormat::WHITE.$j;
				}
				break;
			case "plugins":
				if (($info = $Query->GetInfo()) === false) {
					$c->sendMessage(TextFormat::RED.mc::_("Query of %1%:%2% returned no data", $host,$port));
					return true;
				}
				if (!isset($info["Plugins"])) {
					$c->sendMessage(TextFormat::RED.mc::_("%1%:%2%: No plugins", $host,$port));
					return true;
				}
				$cols = 8;
				$i = 0;
				foreach ($info["Plugins"] as $n) {
					if (($i++ % $cols) == 0) {
						$txt[] = $n;
					} else {
						$txt[count($txt)-1] .= ", ".$n;
					}
				}
				break;
			case "players":
				if (($players = $Query->GetPlayers()) === false) {
					$c->sendMessage(TextFormat::RED.mc::_("Query of %1%:%2% returned no data", $host,$port));
					return true;
				}
				if (count($players) == 0) {
					$c->sendMessage(TextFormat::RED.mc::_("%1%:%2%: No players", $host,$port));
					return true;
				}
				$cols = 8;
				$i = 0;
				foreach ($players as $n) {
					if (($i++ % $cols) == 0) {
						$txt[] = $n;
					} else {
						$txt[count($txt)-1] .= ", ".$n;
					}
				}
				break;
			default:
			  return false;
		}
		return $this->paginateText($c,$pageNumber,$txt);
	}
	private function cmdPlayers(CommandSender $c, $pageNumber) {
		$all = [];
		foreach ($this->owner->getServer()->getOnlinePlayers() as $p) {
			$all[$p->getName()] = mc::_("*current-server*");
		}
		foreach ($this->owner->getModule("ServerList")->getIds() as $id) {
			$dat = $this->owner->getModule("ServerList")->getServer($id);
			$host = $dat["host"];
			$port = $dat["port"];

			$Query = new MinecraftQuery( );
			try {
				$Query->Connect( $host, $port, 1 );
			} catch (MinecraftQueryException $e) {
				$this->owner->getLogger()->warning(mc::_("Query %1% failed: %2%",$host,$e->getMessage()));
				continue;
			}
			if (($players = $Query->GetPlayers()) === false) continue;
			if (count($players) == 0) continue;
			foreach ($players as $p) {
				if ($c->hasPermission("gb.cmd.query.players.showip")) {
					$all[$p] = "$id ($host:$port)";
				} else {
					$all[$p] = "$id";
				}
			}
		}
		if (count($all) == 0) {
			$c->sendMessage(TextFormat::YELLOW."Nobody is on-line at the moment");
		}
		$txt = [ mc::n(mc::_("One player found"),
										mc::_("%1% players found",count($all)),
										count($all)) ];
		ksort($all, SORT_NATURAL);
		foreach ($all as $i=>$j) {
			$txt[] = $i." @ ".$j;
		}
		return $this->paginateText($c,$pageNumber,$txt);
	}
	private function cmdListAll(CommandSender $c, $pageNumber) {
		$all = [];

		$dat = [
			"Players" => count($this->owner->getServer()->getOnlinePlayers()),
			"MaxPlayers" => $this->owner->getServer()->getMaxPlayers(),
			"List" => [],
		];
		foreach ($this->owner->getServer()->getOnlinePlayers() as $p) {
			$dat["List"][] = $p->getName();
		}
		$totals = [
			"Players"=>$dat["Players"],
			"MaxPlayers"=>$dat["MaxPlayers"],
		];
		$all[mc::_("**this-server**")] = $dat;
		foreach ($this->owner->getModule("ServerList")->getIds() as $id) {
			$dat = $this->owner->getModule("ServerList")->getServer($id);
			$host = $dat["host"];
			$port = $dat["port"];

			$Query = new MinecraftQuery( );
			try {
				$Query->Connect( $host, $port, 1 );
			} catch (MinecraftQueryException $e) {
				$this->owner->getLogger()->warning(mc::_("Query %1% failed: %2%",$host,$e->getMessage()));
				continue;
			}
			if (($info = $Query->GetInfo()) === false) continue;
			foreach (["Players","MaxPlayers"] as $i) {
				if (isset($info[$i])) $totals[$i] += $info[$i];
			}
			$all[$id] = [
				"Players" => $info["Players"],
				"MaxPlayers" => $info["MaxPlayers"],
				"List" => $Query->getPlayers(),
			];
		}
		$txt = [ mc::_("Totals: %1%/%2%", $totals["Players"], $totals["MaxPlayers"]) ];
		foreach ($all as $id=>$dat) {
			$txt[] = TextFormat::YELLOW.mc::_("%1% (%2%/%3%):", $id, $dat["Players"], $dat["MaxPlayers"]);
			if (!is_array($dat["List"])) continue;

			$cols = 8;
			$i = 0;
			foreach ($dat["List"] as $n) {
				if (($i++ % $cols) == 0) {
					$txt[] = $n;
				} else {
					$txt[count($txt)-1] .= ", ".$n;
				}
			}

		}

		return $this->paginateText($c,$pageNumber,$txt);
	}
	private function cmdSummary(CommandSender $c) {
		$all = [
			"servers" => 1,
			"on-line" => 1,
			"Players" => count($this->owner->getServer()->getOnlinePlayers()),
			"MaxPlayers" => $this->owner->getServer()->getMaxPlayers(),
		];
		foreach ($this->owner->getModule("ServerList")->getIds() as $id) {
			$dat = $this->owner->getModule("ServerList")->getServer($id);
			$host = $dat["host"];
			$port = $dat["port"];

			$all["servers"]++;

			$Query = new MinecraftQuery( );
			try {
				$Query->Connect( $host, $port, 1 );
			} catch (MinecraftQueryException $e) {
				$this->owner->getLogger()->warning(mc::_("Query %1% failed: %2%",$host,$e->getMessage()));
				continue;
			}
			if (($info = $Query->GetInfo()) === false) continue;
			$all["on-line"]++;
			foreach (["Players","MaxPlayers"] as $i) {
				if (isset($info[$i])) $all[$i] += $info[$i];
			}
		}
		$c->sendMessage(TextFormat::BLUE.mc::_("Network Status"));
		$c->sendMessage(TextFormat::GREEN.mc::_("Servers:%3% %1%/%2%",
																						$all["on-line"],$all["servers"],TextFormat::YELLOW));
		$c->sendMessage(TextFormat::GREEN.mc::_("Players:%3% %1%/%2%",
																						$all["Players"],$all["MaxPlayers"],TextFormat::YELLOW));
		return true;
	}
}
<?php
//= cmd:alias,Server_Management
//: Create a new command alias
//> usage: **alias** **[-f]** _<alias>_ _<command>_ _[options]_
//:
//: Create an alias to a command.
//: Use the **-f** to override existing commands
//:

namespace aliuly\grabbag;

use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\utils\TextFormat;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\Cmd;
use aliuly\grabbag\common\PermUtils;

class AliasCmd implements CommandExecutor {
  protected $cmd;
  public function __construct($owner,$alias,$cmd) {
    Cmd::addCommand($owner, $this, $alias, [
      "description" => mc::_("Alias for %1%", $cmd),
      "usage" => mc::_("/%1% [options]", $alias),
    ]);
    $this->cmd = $cmd;
  }
  public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
    $cmdline = $this->cmd;
    if (count($args)) $cmdline .= " ".implode(" ",$args);
    Cmd::exec($sender,[$cmdline],false);
		return true;
	}
  public function getCmd() {
    return $this->cmd;
  }
}

class CmdAlias extends BasicCli implements CommandExecutor {
  protected $aliases;
	public function __construct($owner) {
		parent::__construct($owner);
		$this->aliases = [];
    PermUtils::add($this->owner, "gb.cmd.alias", "allow creating aliases", "op");
		$this->enableCmd("alias",
							  ["description" => mc::_("Create a command alias"),
								"usage" => mc::_("/alias [-f] [alias [command]]"),
								"permission" => "gb.cmd.alias"]);
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
		switch($cmd->getName()) {
			case "alias":
        return $this->cmdAlias($sender,$args);
		}
		return false;
	}
  public function addAlias($alias,$cmdline,$force) {
    if ($this->owner->getServer()->getCommandMap()->getCommand($alias) !== null) {
      if ($force) {
        MPMU::rmCommand($this->owner->getServer(),$alias);
      } else {
        return false;
      }
    }
    $this->aliases[$alias] = new AliasCmd($this->owner, $alias, $cmdline);
    return true;
  }
  private function cmdAlias(CommandSender $sender,array $args) {
    if (count($args) == 0 || count($args) == 1 && is_numeric($args[0])) return $this->lsAliases($sender,$args);
    if (count($args) == 1)  return $this->showAlias($sender, $args[0]);

    if ($args[0] == "-f") {
      $force = true;
      array_shift($args);
      if (count($args) <= 1) return false;
    } else
      $force = false;

    // Create an alias
    $alias = array_shift($args);
    $cmdline = implode(" ",$args);
    if ($this->cmdAlias($alias,$cmdline,$force)) {
      $sender->sendMessage(TextFormat::GREEN.mc::_("Created alias \"%1%\" as \"%2%\"",$alias,$cmdline));
    } else {
      $sender->sendMessage(TextFormat::RED.mc::_("%1% already exists use -f option", $alias));
    }
    return true;
  }
  private function showAlias(CommandSender $sender, $alias) {
    if (!isset($this->aliases[$alias])) {
      $sender->sendMessage(TextFormat::RED.mc::_("%1% is NOT an alias", $alias));
      return true;
    }
    $sender->sendMessage(TextFormat::GREEN.mc::_("ALIAS:%1%=%2%",$alias, $this->aliases[$alias]->getCmd()));
    return true;
  }
  private function lsAliases(CommandSender $sender, array $args) {
    $pageNumber = $this->getPageNumber($args);
    $txt = [];
    $txt[] = mc::_("Aliases: %1%", count($this->aliases));
    foreach ($this->aliases as $alias=>&$exec) {
      $txt[] = mc::_(TextFormat::GREEN.$alias.": ".TextFormat::WHITE.$exec->getCmd());
    }
    return $this->paginateText($sender,$pageNumber,$txt);
  }
}
<?php
//= cmd:reop,Player_Management
//: Let ops drop priviledges temporarily
//> usage: **reop** [_player_]
//:
//: Will drop **op** priviledges from player.  Player can get **op**
//: back at any time by enter **reop** again or by disconnecting.

namespace aliuly\grabbag;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\event\Listener;
use pocketmine\event\player\PlayerQuitEvent;

use aliuly\grabbag\common\BasicCli;
use aliuly\grabbag\common\mc;
use aliuly\grabbag\common\MPMU;
use aliuly\grabbag\common\PermUtils;

class CmdReOp extends BasicCli implements Listener,CommandExecutor {
	protected $reops;
	public function __construct($owner) {
		parent::__construct($owner);
		PermUtils::add($this->owner, "gb.cmd.reop", "Reop command", "true");
		PermUtils::add($this->owner, "gb.cmd.reop.others", "ReOp others", "op");

		$this->enableCmd("reop",
							  ["description" => mc::_("Temporarily deops administrators"),
								"usage" => mc::_("/reop [player]"),
								"permission" => "gb.cmd.reop"]);
    $this->reops = [];
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
	}
	public function isReOp($target) {
		return isset($this->reops[strtolower($target->getName())]);
	}
	public function reopPlayer($target) {
		$n = strtolower($target->getName());
    if ($target->isOp()) {
			$this->reops[$n] = true;
      $target->setOp(false);
			$target->sendMessage(mc::_("You are no longer Op"));
			return true;
		}
		// Player wants to resume op
    if (isset($this->reops[$n])) {
      $target->setOp(true);
			$target->sendMessage(mc::_("You are now Op"));
      unset($this->reops[$n]);
      return true;
    }
		return false;
	}
	public function onCommand(CommandSender $sender,Command $cmd,$label, array $args) {
    if (count($args) > 1) return false;
		if (count($args) == 0) {
			if (!MPMU::inGame($sender)) return true;
			$target = $sender;
			$other = false;
		} else {
			if (!MPMU::access($sender,"gb.cmd.".$cmd->getName().".others")) return true;
			$target = $this->owner->getServer()->getPlayer($args[0]);
			if ($target === null) {
				$sender->sendMessage(mc::_("%1% can not be found.",$args[0]));
				return true;
			}
			$other = true;
		}
    $n = strtolower($target->getName());
    if ($target->isOp()) {
      // Player is dropping from op...
      $this->reops[$n] = true;
      $target->setOp(false);
      if ($other) $sender->sendMessage(mc::_("%1% is no longer Op",$target->getDisplayName()));
      $target->sendMessage(mc::_("You are no longer Op"));
      return true;
    }

    // Player wants to resume op
    if (isset($this->reops[$n])) {
      $target->setOp(true);
      unset($this->reops[$n]);
      if ($other) $sender->sendMessage(mc::_("%1% is now Op",$target->getDisplayName()));
      $target->sendMessage(mc::_("You are now Op"));
      return true;
    }
    // This player can not be re-opped
    if ($other) {
      $sender->sendMessage(mc::_("That is not possible"));
      return true;
    }
    $sender->sendMessage(mc::_("You are not allowed to do this"));
		return true;
	}
	public function onQuit(PlayerQuitEvent $ev) {
    $n = strtolower($ev->getPlayer()->getName());
    if (!isset($this->reops[$n])) return;
    unset($this->reops[$n]);
    if ($ev->getPlayer()->isOp()) return;
    $ev->getPlayer()->setOp(true);
  }
}
